<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>数组的有序拆分</title>
    <url>/2020/08/25/20-08-25_%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%89%E5%BA%8F%E6%8B%86%E5%88%86/</url>
    <content><![CDATA[<p>实现一个数组的有序拆分<br>给定一个浮点数组及 2个阀值l 和 h，l &lt; h<br>对数组排序满足，数组左边均小于l，右边均大于h，中间部分在[l, h]之间<br>时间复杂度O(N), 额外空间复杂度O(1)</p>
<a id="more"></a>
<p>```python<br>def splitArr(arr, l, h):<br>    def f(arr, l):<br>        length = len(arr)<br>        if length == 0:<br>            return<br>        start = 0<br>        end = length - 1<br>        cur = 0<br>        while cur &lt;= end:<br>            if arr[cur] &lt; l:<br>                arr[cur], arr[start] = arr[start], arr[cur]<br>                start += 1<br>                cur += 1<br>            elif arr[cur] == l:<br>                cur += 1<br>            elif arr[cur] &gt; l:<br>                arr[cur], arr[end] = arr[end], arr[cur]<br>                end -= 1<br>    f(arr, l)<br>    f(arr, h)<br>    return arr</p>
<p>arr = [1,2,5,4,3,7,2,5,1,9,3,2,8]<br>print(splitArr(arr, 4, 5))```</p>
]]></content>
      <categories>
        <category>CODING</category>
        <category>双指针</category>
      </categories>
      <tags>
        <tag>百度</tag>
      </tags>
  </entry>
  <entry>
    <title>删除k个元素使整型字符串最小</title>
    <url>/2020/10/22/20-10-22_%E5%88%A0%E9%99%A4k%E4%B8%AA%E5%85%83%E7%B4%A0%E4%BD%BF%E6%95%B4%E5%9E%8B%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9C%80%E5%B0%8F/</url>
    <content><![CDATA[<p>给定一个整型string，删除k个元素后，使int(string)最小<br>例如，string=”32124”，k=2，输出 124；k=3，输出12</p>
<a id="more"></a>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_min_val</span>(<span class="params">str_nums, k</span>):</span></span><br><span class="line">    <span class="keyword">if</span> k == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">int</span>(str_nums)</span><br><span class="line">    <span class="keyword">while</span> k &gt; <span class="number">0</span>:</span><br><span class="line">        cur = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> cur &lt; <span class="built_in">len</span>(str_nums) - <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">if</span> str_nums[cur] &gt; str_nums[cur + <span class="number">1</span>]:</span><br><span class="line">                str_nums = str_nums[:cur] + str_nums[cur + <span class="number">1</span>:]</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur += <span class="number">1</span></span><br><span class="line">        str_nums = str_nums[:-<span class="number">1</span>] <span class="keyword">if</span> cur == <span class="built_in">len</span>(str_nums) - <span class="number">1</span> <span class="keyword">else</span> str_nums</span><br><span class="line">        k -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">int</span>(str_nums)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">str_nums = <span class="string">&#x27;32513479&#x27;</span></span><br><span class="line">k = <span class="number">2</span></span><br><span class="line">print(get_min_val(str_nums, k))</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>CODING</category>
      </categories>
      <tags>
        <tag>百度</tag>
      </tags>
  </entry>
  <entry>
    <title>只出现一次的字符</title>
    <url>/2020/12/20/20-12-20_%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6/</url>
    <content><![CDATA[<p>数组中只有一个单个元素，其他元素成对，找到只出现一次的元素</p>
<ul>
<li>成对出现，异或 ^，O（N）</li>
<li>成对连续出现，根据奇偶性二分</li>
</ul>
<a id="more"></a>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bs</span>(<span class="params">arr</span>):</span></span><br><span class="line">    left, right = <span class="number">0</span>, <span class="built_in">len</span>(arr) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> left &lt; right:</span><br><span class="line">        mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> mid - <span class="number">1</span> &gt;= left <span class="keyword">and</span> mid + <span class="number">1</span> &lt;= right <span class="keyword">and</span> arr[mid] != arr[mid - <span class="number">1</span>] <span class="keyword">and</span> arr[mid] != arr[mid + <span class="number">1</span>]:</span><br><span class="line">            <span class="keyword">return</span> mid, arr[mid]</span><br><span class="line">        <span class="keyword">elif</span> mid + <span class="number">1</span> &lt;= right <span class="keyword">and</span> arr[mid] == arr[mid + <span class="number">1</span>]:</span><br><span class="line">            length = mid + <span class="number">1</span> - left + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> length % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">                right = mid - <span class="number">1</span> <span class="comment"># mid = mid + 1 且为 mid + 1 左边长度为奇数, right -&gt; mid - 1</span></span><br><span class="line">            <span class="keyword">else</span>: </span><br><span class="line">                left = mid + <span class="number">2</span>  <span class="comment"># mid = mid + 1 且为 mid + 1 右边长度为奇数, right -&gt; mid + 2</span></span><br><span class="line">                <span class="comment"># left = mid</span></span><br><span class="line">        <span class="keyword">elif</span> mid - <span class="number">1</span> &gt;= left <span class="keyword">and</span> arr[mid] == arr[mid - <span class="number">1</span>]:</span><br><span class="line">            length = mid - left + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> length % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">                right = mid - <span class="number">2</span> <span class="comment"># mid - 1 = mid 且为 mid 左边长度为奇数, right -&gt; mid -2</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left = mid + <span class="number">1</span> <span class="comment"># mid - 1 = mid 且为mid 右边长度为奇数, right -&gt; mid + 1</span></span><br><span class="line">    <span class="comment"># left = right</span></span><br><span class="line">    <span class="comment"># 【1，2，2】;【1，1，2】的情况</span></span><br><span class="line">    <span class="keyword">return</span> left, arr[left]</span><br><span class="line"> </span><br><span class="line">arr = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">arr = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">5</span>]</span><br><span class="line">print(bs(arr))</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>CODING</category>
        <category>二分</category>
      </categories>
      <tags>
        <tag>快手</tag>
        <tag>头条</tag>
      </tags>
  </entry>
  <entry>
    <title>柱状图中的最大矩形</title>
    <url>/2020/12/20/20-12-20_%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2/</url>
    <content><![CDATA[<p>给定一个仅包含 0 和 1 的二维二进制矩阵，找出只包含 1 的最大矩形，并返回其面积<br>输入:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">    [<span class="string">&quot;1&quot;</span>,<span class="string">&quot;0&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;0&quot;</span>,<span class="string">&quot;0&quot;</span>],</span><br><span class="line">    [<span class="string">&quot;1&quot;</span>,<span class="string">&quot;0&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;1&quot;</span>],</span><br><span class="line">    [<span class="string">&quot;1&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;1&quot;</span>],</span><br><span class="line">    [<span class="string">&quot;1&quot;</span>,<span class="string">&quot;0&quot;</span>,<span class="string">&quot;0&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;0&quot;</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>输出: 6 </p>
<a id="more"></a>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">largestRectangleArea2</span>(<span class="params">self, heights</span>) -&gt; int:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    暴力法 O(N^2), 以 heights[i] 的高度为高，求左右满足的宽</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    lg = <span class="built_in">len</span>(heights)</span><br><span class="line">    maxx = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(lg):</span><br><span class="line">        tmp = heights[i]</span><br><span class="line">        left, right = i, i</span><br><span class="line">        <span class="keyword">while</span> left &gt; <span class="number">0</span> <span class="keyword">and</span> heights[left - <span class="number">1</span>] &gt;= heights[i]:</span><br><span class="line">            left -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> right &lt; lg - <span class="number">1</span> <span class="keyword">and</span> heights[right + <span class="number">1</span>] &gt;= heights[i]:</span><br><span class="line">            right += <span class="number">1</span></span><br><span class="line">        maxx = <span class="built_in">max</span>(tmp * (right - left + <span class="number">1</span>), maxx)</span><br><span class="line">    <span class="keyword">return</span> maxx</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">largestRectangleArea</span>(<span class="params">heights</span>) -&gt; int:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    单调栈, stack 递增</span></span><br><span class="line"><span class="string">    cur 比 stack[-1]大，入栈; </span></span><br><span class="line"><span class="string">    cur 比 stack[-1]小，依次出栈至 stack[-1]小于cur</span></span><br><span class="line"><span class="string">    以出栈元素的值为高，求宽，更新最值</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    heights.append(<span class="number">0</span>) <span class="comment"># 判断最后一个元素为高的情况</span></span><br><span class="line">    lg = <span class="built_in">len</span>(heights)</span><br><span class="line">    stack = [<span class="number">0</span>]</span><br><span class="line">    maxx = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, lg):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> stack <span class="keyword">and</span> heights[stack[-<span class="number">1</span>]] &lt;= heights[i]:</span><br><span class="line">            stack.append(i)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> heights[stack[-<span class="number">1</span>]] &gt;= heights[i]:</span><br><span class="line">                h = heights[stack[-<span class="number">1</span>]]</span><br><span class="line">                stack.pop()</span><br><span class="line">                <span class="comment"># stack 为空，说明当前height[i] 小于 i之前所有的值</span></span><br><span class="line">                 </span><br><span class="line">                w = i <span class="keyword">if</span> <span class="keyword">not</span> stack <span class="keyword">else</span> i - (stack[-<span class="number">1</span>] + <span class="number">1</span>)</span><br><span class="line">                maxx = <span class="built_in">max</span>(maxx, h*w)</span><br><span class="line">            stack.append(i)</span><br><span class="line">    <span class="keyword">return</span> maxx</span><br><span class="line"><span class="comment"># i=3 结束时，stack = [0,3]；i=4, height[4]=0时，w = i - (0 + 1) = 3</span></span><br><span class="line">heights = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>] </span><br><span class="line">print(largestRectangleArea(heights))</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>CODING</category>
        <category>单调栈</category>
      </categories>
  </entry>
  <entry>
    <title>二叉树的直径</title>
    <url>/2020/12/23/20-12-22_%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/</url>
    <content><![CDATA[<p>给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点<br>示例 :<br>给定二叉树<br>            1<br>          / <br>         2   3<br>        / \<br>       4   5<br>返回 3, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]</p>
<a id="more"></a>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">diameterOfBinaryTree</span>(<span class="params">root</span>) -&gt; int:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">root</span>):</span></span><br><span class="line">        <span class="comment"># 返回: 以root 为根结点的最长路径的最大节点个数</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="comment"># focus on one node</span></span><br><span class="line">        left = dfs(root.left)</span><br><span class="line">        right = dfs(root.right)</span><br><span class="line">        <span class="keyword">global</span> node_nums</span><br><span class="line">        node_nums = <span class="built_in">max</span>(node_nums, left + right + <span class="number">1</span>)</span><br><span class="line">        <span class="comment"># 左右子树只能贡献一边，向上递归</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(left, right) + <span class="number">1</span> </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">global</span> node_nums</span><br><span class="line">    node_nums = <span class="number">1</span></span><br><span class="line">    dfs(root)</span><br><span class="line">    <span class="keyword">return</span> node_nums - <span class="number">1</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>CODING</category>
        <category>树</category>
        <category>回溯_dfs</category>
      </categories>
      <tags>
        <tag>头条</tag>
      </tags>
  </entry>
  <entry>
    <title>sqrt(x)</title>
    <url>/2020/12/22/20-12-22_%E5%BC%80%E5%B9%B3%E6%96%B9/</url>
    <content><![CDATA[<p>给定浮点数x, 求sqrt(x)</p>
<a id="more"></a>

<h1 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h1><ul>
<li>当 x&lt;1 时，注意左右边界<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sqrt</span>(<span class="params">x, error</span>):</span></span><br><span class="line">    <span class="comment"># 二分</span></span><br><span class="line">    <span class="keyword">if</span> x &lt;= <span class="number">1</span>:</span><br><span class="line">        left, right = x, <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        left, right = <span class="number">1</span>, x</span><br><span class="line">    <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">        mid = left + (right - left) / <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">abs</span>(mid * mid - x) &lt;= error:</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        <span class="keyword">elif</span> mid * mid - x &gt; <span class="number">0</span>:</span><br><span class="line">            right = mid</span><br><span class="line">        <span class="keyword">elif</span> mid * mid - x &lt; <span class="number">0</span>:</span><br><span class="line">            left = mid</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="牛顿法"><a href="#牛顿法" class="headerlink" title="牛顿法"></a>牛顿法</h1><ul>
<li>切线是曲线的近似拟合<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sqrt</span>(<span class="params">target, error</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    f(x) = x^2 - target = 0</span></span><br><span class="line"><span class="string">    f&#x27;(x) = 2 * x</span></span><br><span class="line"><span class="string">    切线方程： 2 * x * (x_hat - x) + f(x)</span></span><br><span class="line"><span class="string">    x_hat = (x + target / x) / 2</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    x = target</span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">abs</span>(x * x - target) &gt; error:</span><br><span class="line">        x = (x + target / x) / <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>CODING</category>
        <category>二分</category>
      </categories>
      <tags>
        <tag>快手</tag>
        <tag>好未来</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>打家劫舍I/II/III</title>
    <url>/2020/12/22/20-12-22_%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/</url>
    <content><![CDATA[<p>I<br>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。</p>
<p>II<br>这个地方所有的房屋都围成一圈，这意味着第一个房屋和最后一个房屋是紧挨着的</p>
<p>III<br>这个地方的所有房屋的排列类似于一棵二叉树。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警</p>
<a id="more"></a>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rob1</span>(<span class="params">arr</span>):</span></span><br><span class="line">    size = <span class="built_in">len</span>(arr)</span><br><span class="line">    <span class="keyword">if</span> size == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> size == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> arr[<span class="number">0</span>]</span><br><span class="line">    dp = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(size)]</span><br><span class="line">    dp[<span class="number">0</span>], dp[<span class="number">1</span>] = arr[<span class="number">0</span>], <span class="built_in">max</span>(arr[<span class="number">0</span>], arr[<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, size):</span><br><span class="line">        dp[i] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>], dp[i - <span class="number">2</span>] + arr[i])</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(dp)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rob2</span>(<span class="params">arr</span>):</span></span><br><span class="line">    size = <span class="built_in">len</span>(arr)</span><br><span class="line">    <span class="keyword">if</span> size == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> size == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> arr[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(rob1(arr[:-<span class="number">1</span>]), rob1(arr[<span class="number">1</span>:]))</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rob3</span>(<span class="params">root</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">node</span>):</span></span><br><span class="line">        <span class="comment"># return node 偷 / 不偷 能获取的最大值</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>, <span class="number">0</span> <span class="comment"># 偷， 不偷</span></span><br><span class="line">        left_res = dfs(node.left)</span><br><span class="line">        right_res = dfs(node.right)</span><br><span class="line">        <span class="comment"># 当前 node 偷</span></span><br><span class="line">        res1 = left_res[<span class="number">1</span>] + right_res[<span class="number">1</span>] + node.val</span><br><span class="line">        <span class="comment"># 当前 node 不偷</span></span><br><span class="line">        res2 = <span class="built_in">max</span>(left_res) + <span class="built_in">max</span>(right_res)</span><br><span class="line">        <span class="keyword">return</span> res1, res2</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(dfs(root))</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>CODING</category>
        <category>dp</category>
        <category>树</category>
      </categories>
      <tags>
        <tag>头条</tag>
      </tags>
  </entry>
  <entry>
    <title>数组中的逆序对</title>
    <url>/2020/12/23/20-12-22_%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9/</url>
    <content><![CDATA[<p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P</p>
<a id="more"></a>

<h1 id="暴力法"><a href="#暴力法" class="headerlink" title="暴力法"></a>暴力法</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reversePairs1</span>(<span class="params">nums</span>):</span></span><br><span class="line">    <span class="comment"># O(N^2)</span></span><br><span class="line">    ans, size = <span class="number">0</span>, <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="keyword">if</span> size &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(size - <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i + <span class="number">1</span>, size):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt; nums[j]:</span><br><span class="line">                ans += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<h1 id="归并排序应用"><a href="#归并排序应用" class="headerlink" title="归并排序应用"></a>归并排序应用</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reversePairs2</span>(<span class="params">nums</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge_sort</span>(<span class="params">nums</span>):</span></span><br><span class="line">        <span class="comment"># 递归终止条件</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums) &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> nums</span><br><span class="line">        mid = <span class="built_in">len</span>(nums) // <span class="number">2</span></span><br><span class="line">        l_res = merge_sort(nums[ :mid])</span><br><span class="line">        r_res = merge_sort(nums[mid: ])</span><br><span class="line">        <span class="keyword">return</span> merge(l_res, r_res)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">left, right</span>):</span></span><br><span class="line">        lst = []</span><br><span class="line">        i, j = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(left) <span class="keyword">and</span> j &lt; <span class="built_in">len</span>(right):</span><br><span class="line">            <span class="keyword">if</span> left[i] &lt;= right[j]:</span><br><span class="line">                lst.append(left[i])</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">global</span> ans</span><br><span class="line">                ans += <span class="built_in">len</span>(left) - i</span><br><span class="line">                lst.append(right[j])</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">        lst.extend(left[i:])</span><br><span class="line">        lst.extend(right[j:])</span><br><span class="line">        <span class="keyword">return</span> lst</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">global</span> ans</span><br><span class="line">    ans = <span class="number">0</span></span><br><span class="line">    nums_sorted = merge_sort(nums)</span><br><span class="line">    <span class="keyword">return</span> nums_sorted, ans</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>CODING</category>
        <category>排序</category>
      </categories>
      <tags>
        <tag>头条</tag>
        <tag>排序应用</tag>
      </tags>
  </entry>
  <entry>
    <title>最长有效括号长度</title>
    <url>/2020/12/22/20-12-22_%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7%E9%95%BF%E5%BA%A6/</url>
    <content><![CDATA[<p>给定一个只包含 ‘(‘ 和 ‘)’ 的字符串，找出最长的包含有效括号的子串的长度<br>示例 1:<br>输入: “(()”<br>输出: 2<br>解释: 最长有效括号子串为 “()”</p>
<p>示例 2:<br>输入: “)()())”<br>输出: 4<br>解释: 最长有效括号子串为 “()()”</p>
<a id="more"></a>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longestValidParentheses</span>(<span class="params">s: <span class="built_in">str</span></span>) -&gt; int:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    dp[i]: 以s[i]结尾的最长有效括号子串长度</span></span><br><span class="line"><span class="string">    if s[i] = &#x27;(&#x27;:</span></span><br><span class="line"><span class="string">        dp[i] = 0</span></span><br><span class="line"><span class="string">    else: # s[i] = &#x27;)&#x27;</span></span><br><span class="line"><span class="string">        if s[i - 1] = &#x27;(&#x27;:</span></span><br><span class="line"><span class="string">            dp[i] = dp[i - 1] + 2 </span></span><br><span class="line"><span class="string">        else: # s[i - 1] = &#x27;)&#x27;</span></span><br><span class="line"><span class="string">            if s[i - dp[i - 1] - 1] = &#x27;(&#x27;:</span></span><br><span class="line"><span class="string">                dp[i] = 2 + dp[i - 1] + dp[i - dp[i - 1] - 1 - 1]</span></span><br><span class="line"><span class="string">    注意可能越界, i &gt; 0，i - dp[i - 1] - 1 &gt;= 0</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    dp = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s))]</span><br><span class="line">    ans = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">        <span class="keyword">if</span> s[i] == <span class="string">&#x27;)&#x27;</span>:<span class="comment"># 只考虑以&#x27;)&#x27;结尾的子串</span></span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> s[i - <span class="number">1</span>] == <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">                dp[i] = dp[i - <span class="number">2</span>] + <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> s[i - <span class="number">1</span>] == <span class="string">&#x27;)&#x27;</span>:</span><br><span class="line">                <span class="keyword">if</span> i - dp[i - <span class="number">1</span>] - <span class="number">1</span> &gt;= <span class="number">0</span> <span class="keyword">and</span> s[i - dp[i - <span class="number">1</span>] - <span class="number">1</span>] == <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">                    <span class="keyword">if</span> i - dp[i - <span class="number">1</span>] - <span class="number">2</span> &gt;= <span class="number">0</span>:<span class="comment"># 当前合法子串，前面还有子串的情况</span></span><br><span class="line">                        dp[i] = <span class="number">2</span> + dp[i - <span class="number">1</span>] + dp[i - dp[i - <span class="number">1</span>] - <span class="number">2</span>]</span><br><span class="line">                    <span class="keyword">else</span>: <span class="comment"># 当前合法子串，前面没有子串的情况</span></span><br><span class="line">                        dp[i] = <span class="number">2</span> + dp[i - <span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(dp)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longestValidParentheses2</span>(<span class="params">s: <span class="built_in">str</span></span>) -&gt; int:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    中心拓展法 def expand(l, r)</span></span><br><span class="line"><span class="string">    return [l, r]: 有效括号的左右边界</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    dic = &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">expand</span>(<span class="params">l, r</span>):</span></span><br><span class="line">        <span class="keyword">while</span> l &gt;= <span class="number">0</span> <span class="keyword">and</span> r &lt; <span class="built_in">len</span>(s) <span class="keyword">and</span> s[l] == <span class="string">&#x27;(&#x27;</span> <span class="keyword">and</span> s[r] == <span class="string">&#x27;)&#x27;</span>:</span><br><span class="line">            l -= <span class="number">1</span></span><br><span class="line">            r += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> l + <span class="number">1</span> - <span class="number">1</span> <span class="keyword">in</span> dic:</span><br><span class="line">            <span class="keyword">return</span> expand(dic[l + <span class="number">1</span> - <span class="number">1</span>], r - <span class="number">1</span>)</span><br><span class="line">        dic[r - <span class="number">1</span>] = l + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> [l + <span class="number">1</span>, r - <span class="number">1</span>]</span><br><span class="line">    </span><br><span class="line">    ans = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s) - <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> s[i] == <span class="string">&#x27;(&#x27;</span> <span class="keyword">and</span> s[i + <span class="number">1</span>] == <span class="string">&#x27;)&#x27;</span>:</span><br><span class="line">            l, r = expand(i, i + <span class="number">1</span>)</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, r - l + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longestValidParentheses3</span>(<span class="params">s</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    栈</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    q = []</span><br><span class="line">    start, ans = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">        <span class="keyword">if</span> s[i] == <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">            q.append(i)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> q: </span><br><span class="line">                start = i + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                q.pop()</span><br><span class="line">                <span class="keyword">if</span> q:</span><br><span class="line">                    ans = <span class="built_in">max</span>(ans, i - q[-<span class="number">1</span>])</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    ans = <span class="built_in">max</span>(ans, i - start + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>CODING</category>
        <category>dp</category>
      </categories>
      <tags>
        <tag>滴滴</tag>
      </tags>
  </entry>
  <entry>
    <title>滑动窗口最大值</title>
    <url>/2020/12/22/20-12-22_%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC/</url>
    <content><![CDATA[<p>给定一个数组 nums 和滑动窗口的大小 k，请找出所有滑动窗口里的最大值<br>示例:<br>输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3<br>输出: [3,3,5,5,6,7]<br>解释:<br>    [1  3  -1] -3  5  3  6  7   =&gt; 3<br>    1 [3  -1  -3] 5  3  6  7    =&gt; 3<br>    1  3 [-1  -3  5] 3  6  7    =&gt; 5<br>    1  3  -1 [-3  5  3] 6  7    =&gt; 5<br>    1  3  -1  -3 [5  3  6] 7    =&gt; 6<br>    1  3  -1  -3  5 [3  6  7]   =&gt; 7<br>提示：你可以假设 k 总是有效的，在输入数组不为空的情况下，1 ≤ k ≤ 输入数组的大小</p>
<a id="more"></a>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxSlidingWindow</span>(<span class="params">nums, k</span>):</span></span><br><span class="line">    <span class="comment"># 暴力法， O(KN)</span></span><br><span class="line">    left, right = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    lst = []</span><br><span class="line">    <span class="keyword">while</span> right &lt;= <span class="built_in">len</span>(nums) - <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">while</span> right - left &lt; k:</span><br><span class="line">            right += <span class="number">1</span></span><br><span class="line">        lst.append(<span class="built_in">max</span>(nums[left: right]))</span><br><span class="line">        left += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> lst</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxSlidingWindow</span>(<span class="params">nums, k</span>):</span></span><br><span class="line">    <span class="comment"># 单调栈</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    res, stack = [], []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">        <span class="comment"># 窗口左边的元素弹出</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(stack) &gt; <span class="number">0</span> <span class="keyword">and</span> stack[<span class="number">0</span>] &lt;= i - k:</span><br><span class="line">            stack.pop(<span class="number">0</span>)</span><br><span class="line">        <span class="comment"># 维护栈内元素有序</span></span><br><span class="line">        <span class="keyword">while</span> stack <span class="keyword">and</span> nums[stack[-<span class="number">1</span>]] &lt; nums[i]:</span><br><span class="line">            stack.pop()</span><br><span class="line">        stack.append(i)</span><br><span class="line">        <span class="keyword">if</span> i &gt;= k - <span class="number">1</span>:</span><br><span class="line">            res.append(nums[stack[<span class="number">0</span>]])</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>CODING</category>
        <category>单调栈</category>
      </categories>
      <tags>
        <tag>头条</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树镜像</title>
    <url>/2020/12/23/20-12-23_%E4%BA%8C%E5%8F%89%E6%A0%91%E9%95%9C%E5%83%8F/</url>
    <content><![CDATA[<p>完成一个函数，输入一个二叉树，该函数输出它的镜像。<br>例如输入：<br>   4<br>  / \<br>  2  7<br> / \ / \<br> 1 3 6 9<br>镜像输出：<br>  4<br> / \<br> 7  2<br>/ \ / \<br>9 6 3 1 </p>
<a id="more"></a>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mirrorTree1</span>(<span class="params">root</span>):</span></span><br><span class="line">    <span class="comment"># 递归</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    root.left, root.right = root.right, root.left</span><br><span class="line">    mirrorTree1(root.left)</span><br><span class="line">    mirrorTree1(root.right)</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mirrorTree2</span>(<span class="params">root</span>):</span></span><br><span class="line">    <span class="comment"># 非递归</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    queue = []</span><br><span class="line">    queue.append(root)</span><br><span class="line">    <span class="keyword">while</span> queue:</span><br><span class="line">        cur = queue.pop(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span> cur.left:</span><br><span class="line">            queue.append(cur.left)</span><br><span class="line">        <span class="keyword">if</span> cur.right:</span><br><span class="line">            queue.append(cur.right)</span><br><span class="line">        cur.left, cur.right = cur.right, cur.left</span><br><span class="line">    <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>CODING</category>
        <category>递归</category>
        <category>树</category>
      </categories>
  </entry>
  <entry>
    <title>二叉树中和为某一值的路径</title>
    <url>/2020/12/24/20-12-24_%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<p>输入一棵二叉树和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。从树的根节点开始往下一直到叶节点所经过的节点形成一条路径</p>
<a id="more"></a>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pathSum</span>(<span class="params">root, summ: <span class="built_in">int</span></span>):</span></span><br><span class="line">    res, path = [], []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">recur</span>(<span class="params">root, target</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        path.append(root.val)</span><br><span class="line">        target -= root.val</span><br><span class="line">        <span class="comment"># 如果满足条件【路径，且 和等于target】</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right <span class="keyword">and</span> target == <span class="number">0</span>:</span><br><span class="line">            res.append(path[:]) <span class="comment"># copy, 否则后面改变会影响前面的值</span></span><br><span class="line">        <span class="comment"># 不满足条件，递归</span></span><br><span class="line">        <span class="keyword">if</span> root.left:</span><br><span class="line">            recur(root.left, target)</span><br><span class="line">        <span class="keyword">if</span> root.right:</span><br><span class="line">            recur(root.right, target)</span><br><span class="line">        path.pop()</span><br><span class="line">    recur(root, summ)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>CODING</category>
        <category>树</category>
        <category>回溯_dfs</category>
      </categories>
  </entry>
  <entry>
    <title>把数组排成最小的数</title>
    <url>/2020/12/24/20-12-24_%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0/</url>
    <content><![CDATA[<p>输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。<br>示例 1:<br>输入: [10,2]<br>输出: “102” </p>
<p>示例 2:<br>输入: [3,30,34,5,9]<br>输出: “3033459”</p>
<a id="more"></a>

<h1 id="暴力法"><a href="#暴力法" class="headerlink" title="暴力法"></a>暴力法</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minNumber</span>(<span class="params">nums</span>) -&gt; str:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">compare</span>(<span class="params">a: <span class="built_in">str</span>, b: <span class="built_in">str</span></span>)-&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">int</span>(a + b) &gt;= <span class="built_in">int</span>(b + a):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    strs = [<span class="built_in">str</span>(num) <span class="keyword">for</span> num <span class="keyword">in</span> nums]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(strs)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i + <span class="number">1</span>, <span class="built_in">len</span>(strs)):</span><br><span class="line">            <span class="keyword">if</span> compare(strs[i], strs[j]):</span><br><span class="line">                strs[i], strs[j] = strs[j], strs[i]</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(strs)</span><br></pre></td></tr></table></figure>
<h1 id="快排及应用"><a href="#快排及应用" class="headerlink" title="快排及应用"></a>快排及应用</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span>(<span class="params">num_str</span>) -&gt; str:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">partition</span>(<span class="params">left, right</span>):</span></span><br><span class="line">        <span class="keyword">if</span> left &gt;= right:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        i, j = left, right</span><br><span class="line">        <span class="keyword">while</span> i &lt; j:</span><br><span class="line">            <span class="keyword">while</span> nums[j] &gt;= nums[left] <span class="keyword">and</span> i &lt; j:</span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> nums[i] &lt;= nums[left] <span class="keyword">and</span> i &lt; j:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            nums[i], nums[j] = nums[j], nums[i]</span><br><span class="line">        <span class="comment"># 找到合适的i, i的左边均 “小于” left, i的右边均 “大于” left</span></span><br><span class="line">        nums[left], nums[i] = nums[i], nums[left]</span><br><span class="line">        partition(left, i - <span class="number">1</span>)</span><br><span class="line">        partition(i + <span class="number">1</span>, right)</span><br><span class="line">    partition(<span class="number">0</span>, <span class="built_in">len</span>(num_str) - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> nums</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minNumber</span>(<span class="params">num_str</span>) -&gt; str:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span>(<span class="params">left, right</span>):</span></span><br><span class="line">        <span class="keyword">if</span> left &gt;= right:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        i, j = left, right</span><br><span class="line">        <span class="keyword">while</span> i &lt; j:</span><br><span class="line">            <span class="comment"># 排序规则变动</span></span><br><span class="line">            <span class="comment"># str_a + str_b &gt; str_b + str_a, 定义 str_a &quot;大于&quot; str_b</span></span><br><span class="line">            <span class="comment"># 反之, str_a &quot;小于&quot; str_b</span></span><br><span class="line">            <span class="keyword">while</span> nums[j] + nums[left] &gt;= nums[left] + nums[j] <span class="keyword">and</span> i &lt; j:</span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">            <span class="comment"># nums[j] + nums[left] &lt; nums[left] + nums[j], j &quot;小于&quot; left</span></span><br><span class="line">            <span class="keyword">while</span> nums[i] + nums[left] &lt;= nums[left] + nums[i] <span class="keyword">and</span> i &lt; j:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="comment"># nums[i] + nums[left] &lt; nums[left] + nums[i], i &quot;大于&quot; left </span></span><br><span class="line">            nums[i], nums[j] = nums[j], nums[i]</span><br><span class="line">        <span class="comment"># 找到合适的i, i的左边均 “小于” left, i的右边均 “大于” left</span></span><br><span class="line">        nums[left], nums[i] = nums[i], nums[left]</span><br><span class="line">        quick_sort(left, i - <span class="number">1</span>)</span><br><span class="line">        quick_sort(i + <span class="number">1</span>, right)</span><br><span class="line">    nums = [<span class="built_in">str</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> num_str]</span><br><span class="line">    quick_sort(<span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(nums)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>CODING</category>
        <category>排序</category>
      </categories>
      <tags>
        <tag>排序应用</tag>
      </tags>
  </entry>
  <entry>
    <title>分割等和子集</title>
    <url>/2020/12/25/20-12-25_%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86/</url>
    <content><![CDATA[<p>给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。<br>注意: 每个数组中的元素不会超过 100 , 数组的大小不会超过 200<br>示例 1:<br>输入: [1, 5, 11, 5], 输出: true<br>解释: 数组可以分割成 [1, 5, 5] 和 [11].<br>示例 2:<br>输入: [1, 2, 3, 5], 输出: false<br>解释: 数组不能分割成两个元素和相等的子集.</p>
<a id="more"></a>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">canPartition</span>(<span class="params">nums</span>) -&gt; bool:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    dp[i][j]: 前i个是否能凑出j，return dp[size][target]</span></span><br><span class="line"><span class="string">    dp[][0] = True, dp[0][] = False, dp[0][0] = False</span></span><br><span class="line"><span class="string">    dp[i][j] = dp[i - 1][j] or dp[i - 1][j - nums[i - 1]]</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    summ = <span class="built_in">sum</span>(nums)</span><br><span class="line">    <span class="keyword">if</span> summ % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    size, target = <span class="built_in">len</span>(nums), summ // <span class="number">2</span></span><br><span class="line">    dp = [[<span class="literal">False</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(size + <span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(target + <span class="number">1</span>)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, size + <span class="number">1</span>):</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, size + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, target + <span class="number">1</span>):</span><br><span class="line">            dp[i][j] = dp[i - <span class="number">1</span>][j] <span class="keyword">or</span> dp[i - <span class="number">1</span>][j - nums[i - <span class="number">1</span>]]</span><br><span class="line">    <span class="keyword">return</span> dp[-<span class="number">1</span>][-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>CODING</category>
        <category>dp</category>
      </categories>
      <tags>
        <tag>背包问题</tag>
      </tags>
  </entry>
  <entry>
    <title>旋转排序数组</title>
    <url>/2020/12/28/20-12-28-%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2]，注意数组中可能存在重复的元素。 </p>
<ul>
<li>找出其中最小的元素</li>
<li>找出指定的元素target，若不存在返回-1</li>
</ul>
<a id="more"></a>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findMin</span>(<span class="params">nums</span>) -&gt; int:</span></span><br><span class="line">    left, right = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> left &lt; right: <span class="comment"># 终止条件 left=right</span></span><br><span class="line">        mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] &gt; nums[right]:</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> nums[mid] &lt; nums[right]:</span><br><span class="line">            right = mid</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            right -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> nums[left] <span class="comment"># or nums[right]</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findTarget</span>(<span class="params">nums, target</span>) -&gt; int:</span></span><br><span class="line">    left, right = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> left &lt; right:</span><br><span class="line">        mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] &gt; nums[left]:</span><br><span class="line">            <span class="comment"># [left, mid) 有序</span></span><br><span class="line">            <span class="keyword">if</span> nums[left] &lt;= target <span class="keyword">and</span> target &lt;= nums[mid]:</span><br><span class="line">                right = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> nums[mid] &lt; nums[left]:</span><br><span class="line">            <span class="comment"># [left, mid) 不递增 [5,6,7,1,2,3]</span></span><br><span class="line">            <span class="keyword">if</span> target &gt;= nums[left] <span class="keyword">or</span> target &lt;= nums[mid]:</span><br><span class="line">                right = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> nums[mid] == nums[left]:</span><br><span class="line">            <span class="comment"># [8,1,2,8,8]</span></span><br><span class="line">            <span class="keyword">if</span> nums[left] == target:</span><br><span class="line">                right = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> left <span class="keyword">if</span> nums[left] == target <span class="keyword">else</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>CODING</category>
        <category>二分</category>
      </categories>
      <tags>
        <tag>快手</tag>
        <tag>好未来</tag>
        <tag>滴滴</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式匹配</title>
    <url>/2020/12/28/20-12-28-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/</url>
    <content><![CDATA[<p>给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 ‘.’ 和 ‘<em>‘ 的正则表达式匹配，’.’ 匹配任意单个字符，’</em>‘ 匹配零个或多个前面的那一个元素。所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串<br>示例 1<br>输入：s = “aa” p = “a”，输出：false，解释：”a” 无法匹配 “aa” 整个字符串<br>示例 2<br>输入：s = “ab” p = “.<em>“，输出：true，解释：”.</em>“ 表示可匹配零个或多个（’<em>‘）任意字符（’.’）<br>示例 3<br>输入：s = “aab” p = “c</em>a<em>b”，输出：true，解释：因为 ‘</em>‘ 表示零个或多个，这里 ‘c’ 为 0 个, ‘a’ 被重复一次。因此可以匹配字符串 “aab”</p>
<a id="more"></a>
<img src="/images/正则表达式.jpg" width=80% height=50% align=center/>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isMatch</span>(<span class="params">s: <span class="built_in">str</span>, p: <span class="built_in">str</span></span>) -&gt; bool:</span></span><br><span class="line">    <span class="comment"># 边界条件，考虑 s 或 p 分别为空的情况</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> p: </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> s</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> s <span class="keyword">and</span> <span class="built_in">len</span>(p) == <span class="number">1</span>: </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    m, n = <span class="built_in">len</span>(s), <span class="built_in">len</span>(p)</span><br><span class="line">    dp = [[<span class="literal">False</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m + <span class="number">1</span>)]</span><br><span class="line">    <span class="comment"># 初始状态</span></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">True</span></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> p[j - <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>: <span class="comment"># p的第j个</span></span><br><span class="line">            dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j - <span class="number">2</span>] <span class="comment"># p的前 j 个 与 前 j-2 个的关系</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,m + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> s[i - <span class="number">1</span>] == p[j - <span class="number">1</span>] <span class="keyword">or</span> p[j - <span class="number">1</span>] == <span class="string">&#x27;.&#x27;</span>:</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">elif</span> p[j - <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                <span class="comment"># ‘*’前面的字符匹配s[i] 或者为&#x27;.&#x27;</span></span><br><span class="line">                <span class="keyword">if</span> p[j - <span class="number">2</span>] == s[i - <span class="number">1</span>] <span class="keyword">or</span> p[j - <span class="number">2</span>] == <span class="string">&#x27;.&#x27;</span>:</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j] <span class="keyword">or</span> dp[i][j - <span class="number">2</span>]</span><br><span class="line">                <span class="comment"># ‘*’匹配了0次前面的字符</span></span><br><span class="line">                <span class="keyword">else</span>:                       </span><br><span class="line">                    dp[i][j] = dp[i][j - <span class="number">2</span>] </span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dp[i][j] = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> dp[m][n]</span><br><span class="line">s = <span class="string">&quot;aab&quot;</span></span><br><span class="line">p = <span class="string">&quot;c*a*b&quot;</span></span><br><span class="line"><span class="comment">#s = &quot;&quot;, p = &#x27;.*&#x27; # true</span></span><br><span class="line">print(isMatch(s, p))</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>CODING</category>
        <category>dp</category>
      </categories>
  </entry>
  <entry>
    <title>顺时针打印矩阵</title>
    <url>/2020/12/28/20-12-28-%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5/</url>
    <content><![CDATA[<p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字<br>示例 1<br>输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]<br>输出：[1,2,3,6,9,8,7,4,5]<br>示例 2<br>输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]<br>输出：[1,2,3,4,8,12,11,10,9,5,6,7]</p>
<a id="more"></a>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">spiralOrder</span>(<span class="params">matrix</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> matrix:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    left, right, top, bottom, res = <span class="number">0</span>, <span class="built_in">len</span>(matrix[<span class="number">0</span>]) - <span class="number">1</span>, <span class="number">0</span>, <span class="built_in">len</span>(matrix) - <span class="number">1</span>, []</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(left, right + <span class="number">1</span>):</span><br><span class="line">            res.append(matrix[top][i])<span class="comment"># 从左到右</span></span><br><span class="line">        top += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> top &gt; bottom:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(top, bottom + <span class="number">1</span>):</span><br><span class="line">            res.append(matrix[j][right]) <span class="comment"># 从下到上</span></span><br><span class="line">        right -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> right &lt; left:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(right, left - <span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            res.append(matrix[bottom][k]) <span class="comment"># 从右到左</span></span><br><span class="line">        bottom -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> top &gt; bottom:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">for</span> l <span class="keyword">in</span> <span class="built_in">range</span>(bottom, top - <span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            res.append(matrix[l][left]) <span class="comment"># 从上到下</span></span><br><span class="line">        left += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> right &lt; left:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>CODING</category>
      </categories>
      <tags>
        <tag>快手</tag>
        <tag>头条</tag>
        <tag>滴滴</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串中的所有回文子串</title>
    <url>/2020/12/29/20-12-29_%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</url>
    <content><![CDATA[<p>给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。 具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。<br>示例 1：<br>输入：”abc”, 输出：3, 解释：三个回文子串: “a”, “b”, “c”<br>示例 2：<br>输入：”aaa”, 输出：6, 解释：6个回文子串: “a”, “a”, “a”, “aa”, “aa”, “aaa”</p>
<a id="more"></a>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 中心拓展法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countSubstrings</span>(<span class="params">self, s</span>) -&gt; int:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">spread</span>(<span class="params">left, right</span>):</span></span><br><span class="line">            count = <span class="number">0</span></span><br><span class="line">            res_lst = []</span><br><span class="line">            <span class="keyword">while</span> left &gt;= <span class="number">0</span> <span class="keyword">and</span> right &lt;= <span class="built_in">len</span>(s) - <span class="number">1</span> <span class="keyword">and</span> s[left] == s[right]:</span><br><span class="line">                res_lst.append(s[left: right+<span class="number">1</span>])</span><br><span class="line">                left -= <span class="number">1</span></span><br><span class="line">                right += <span class="number">1</span></span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> count, res_lst</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        lst = []</span><br><span class="line">        <span class="comment"># 奇数情况，中心点为一个元素</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">            tmp1, tmp2 = spread(i, i)</span><br><span class="line">            ans += tmp1</span><br><span class="line">            <span class="keyword">if</span> tmp2:</span><br><span class="line">                lst.extend(tmp2)</span><br><span class="line">        <span class="comment"># 偶数情况，中心点为两个元素</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s) - <span class="number">1</span>):</span><br><span class="line">            tmp1, tmp2 = spread(j, j+<span class="number">1</span>)</span><br><span class="line">            ans += tmp1</span><br><span class="line">            <span class="keyword">if</span> tmp2:</span><br><span class="line">                lst.extend(tmp2)        </span><br><span class="line">        <span class="keyword">return</span> ans, lst</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 动态规划法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countSubstrings2</span>(<span class="params">self, s</span>) -&gt; int:</span></span><br><span class="line">        <span class="comment"># dp[i][j] 第i个到第j个字符的字串是否为回文</span></span><br><span class="line">        length = <span class="built_in">len</span>(s)</span><br><span class="line">        dp = [[<span class="literal">False</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(length)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(length)]</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        lst = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i + <span class="number">1</span>):</span><br><span class="line">                n = i - j + <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">                    dp[j][i] = <span class="literal">True</span></span><br><span class="line">                    lst.append(s[j:i+<span class="number">1</span>])</span><br><span class="line">                    count += <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> n == <span class="number">2</span> <span class="keyword">and</span> s[i] == s[j]:</span><br><span class="line">                    dp[j][i] = <span class="literal">True</span></span><br><span class="line">                    lst.append(s[j:i+<span class="number">1</span>])</span><br><span class="line">                    count += <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> n &gt; <span class="number">2</span> <span class="keyword">and</span> s[i] == s[j] <span class="keyword">and</span> dp[j+<span class="number">1</span>][i-<span class="number">1</span>]:</span><br><span class="line">                    dp[j][i] = <span class="literal">True</span></span><br><span class="line">                    lst.append(s[j:i+<span class="number">1</span>])</span><br><span class="line">                    count += <span class="number">1</span></span><br><span class="line">            print(dp)</span><br><span class="line">        <span class="keyword">return</span> count, lst</span><br><span class="line">s = <span class="string">&quot;aaa&quot;</span></span><br><span class="line"><span class="comment"># s = &quot;abc&quot;</span></span><br><span class="line">print(Solution().countSubstrings(s))</span><br><span class="line">print(Solution().countSubstrings2(s))</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>CODING</category>
        <category>dp</category>
      </categories>
      <tags>
        <tag>美团</tag>
        <tag>子串</tag>
      </tags>
  </entry>
  <entry>
    <title>每日温度</title>
    <url>/2020/12/29/20-12-29_%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6/</url>
    <content><![CDATA[<p>请根据每日 气温 列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用 0 来代替<br>例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。 </p>
<a id="more"></a>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dailyTemperatures</span>(<span class="params">T</span>):</span></span><br><span class="line">    stack = [] <span class="comment"># 存放index</span></span><br><span class="line">    res = [<span class="number">0</span>] * <span class="built_in">len</span>(T)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(T) - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">while</span> stack <span class="keyword">and</span> T[stack[-<span class="number">1</span>]] &lt;= T[i]: <span class="comment"># stack[-1]是index</span></span><br><span class="line">            stack.pop(-<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> stack:</span><br><span class="line">            res[i] = (stack[-<span class="number">1</span>] - i) <span class="comment"># res 存放距离，即index的差</span></span><br><span class="line">        stack.append(i)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">temperatures = [<span class="number">73</span>, <span class="number">74</span>, <span class="number">75</span>, <span class="number">71</span>, <span class="number">69</span>, <span class="number">72</span>, <span class="number">76</span>, <span class="number">73</span>]</span><br><span class="line">print(dailyTemperatures(temperatures))</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>CODING</category>
        <category>单调栈</category>
      </categories>
  </entry>
  <entry>
    <title>字符串消除连续出现的字符</title>
    <url>/2021/01/08/21-01-08_%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%B6%88%E9%99%A4%E8%BF%9E%E7%BB%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E5%AD%97%E7%AC%A6/</url>
    <content><![CDATA[<p>给你一个字符串 s，「k 倍重复项删除操作」将会从 s 中选择 k 个相邻且相等的字母，并删除它们，使被删去的字符串的左侧和右侧连在一起。 你需要对 s 重复进行无限次这样的删除操作，直到无法继续为止。 在执行完所有删除操作后，返回最终得到的字符串。本题答案保证唯一。 </p>
<p>输入：s = “abcd”, k = 2, 输出：”abcd”<br>解释：没有要删除的内容。 </p>
<p>输入：s = “deeedbbcccbdaa”, k = 3, 输出：”aa”<br>解释：先删除 “eee” 和 “ccc”，得到 “ddbbbdaa”, 再删除 “bbb”，得到 “dddaa”, 最后删除 “ddd”，得到 “aa” </p>
<p>输入：s = “pbbcggttciiippooaais”, k = 2, 输出：”ps”</p>
<a id="more"></a>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">removeDuplicates</span>(<span class="params">s: <span class="built_in">str</span>, k: <span class="built_in">int</span></span>) -&gt; str:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    字符串消除连续出现 k次 的字符</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    stack = []</span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> stack <span class="keyword">or</span> stack[-<span class="number">1</span>][<span class="number">0</span>] != c:</span><br><span class="line">            stack.append([c, <span class="number">1</span>])</span><br><span class="line">        <span class="keyword">elif</span> stack[-<span class="number">1</span>][<span class="number">1</span>] + <span class="number">1</span> &lt; k:</span><br><span class="line">            stack[-<span class="number">1</span>][<span class="number">1</span>] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            stack.pop()</span><br><span class="line">    ans = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> c, l <span class="keyword">in</span> stack:</span><br><span class="line">        ans += c * l</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">removeDuplicates_1</span>(<span class="params">s, k</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    字符串消除连续出现 k次 的字符</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    i, j = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(s):</span><br><span class="line">        j = i</span><br><span class="line">        <span class="keyword">while</span> j &lt; <span class="built_in">len</span>(s) <span class="keyword">and</span> j - i &lt; k <span class="keyword">and</span> s[j] == s[i]:</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> j - i &gt;= k:</span><br><span class="line">            s = s[:i] + s[j:]</span><br><span class="line">            i -= (k - <span class="number">1</span>)</span><br><span class="line">            i = i <span class="keyword">if</span> i &gt;= <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">removeDuplicates_2</span>(<span class="params">s, k</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    字符串消除连续出现 k次及以上 的字符</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    i, j = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(s):</span><br><span class="line">        j = i</span><br><span class="line">        <span class="keyword">while</span> j &lt; <span class="built_in">len</span>(s) <span class="keyword">and</span> s[j] == s[i]:</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> j - i &gt;= k:</span><br><span class="line">            s = s[:i] + s[j:]</span><br><span class="line">            i -= (k - <span class="number">1</span>)</span><br><span class="line">            i = i <span class="keyword">if</span> i &gt;= <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> s</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>CODING</category>
      </categories>
      <tags>
        <tag>头条</tag>
        <tag>天眼查</tag>
      </tags>
  </entry>
  <entry>
    <title>上凸函数采样点找最大值</title>
    <url>/2021/01/05/21-01-05_%E4%B8%8A%E5%87%B8%E5%87%BD%E6%95%B0%E9%87%87%E6%A0%B7%E7%82%B9%E6%89%BE%E6%9C%80%E5%A4%A7%E5%80%BC/</url>
    <content><![CDATA[<p>给定上凸函数采样点数组，例如[-1, 5, 8, 9, 10, 8, 5, 3, 2, 1]，找最大值<br>注：有序数组旋转后，后半部分倒序同样为上凸函数采样点 [5, 6, 7, 8, 1, 2, 3, 4] -&gt; [5, 6, 7, 8, 4, 3, 2, 1]</p>
<a id="more"></a>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_maxx_from_convex_sample</span>(<span class="params">arr</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> arr:</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    left, right = <span class="number">0</span>, <span class="built_in">len</span>(arr)</span><br><span class="line">    <span class="keyword">while</span> left &lt; right:</span><br><span class="line">        mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> mid - <span class="number">1</span> &gt;= <span class="number">0</span> <span class="keyword">and</span> mid + <span class="number">1</span> &lt;= <span class="built_in">len</span>(arr) - <span class="number">1</span> <span class="keyword">and</span> arr[mid - <span class="number">1</span>] &lt; arr[mid] <span class="keyword">and</span> arr[mid] &gt; arr[mid + <span class="number">1</span>]:</span><br><span class="line">            <span class="keyword">return</span> arr[mid]</span><br><span class="line">        <span class="keyword">elif</span> mid - <span class="number">1</span> &gt;= <span class="number">0</span> <span class="keyword">and</span> arr[mid - <span class="number">1</span>] &lt; arr[mid]:</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> mid + <span class="number">1</span> &lt;= <span class="built_in">len</span>(arr) - <span class="number">1</span> <span class="keyword">and</span> arr[mid] &gt; arr[mid + <span class="number">1</span>]:</span><br><span class="line">            right = mid</span><br><span class="line">    <span class="keyword">return</span> arr[left]</span><br><span class="line"></span><br><span class="line">arr = [-<span class="number">1</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br><span class="line">print(get_maxx_from_convex_sample(arr))</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>CODING</category>
        <category>二分</category>
      </categories>
      <tags>
        <tag>阿里</tag>
      </tags>
  </entry>
  <entry>
    <title>最长子串相关</title>
    <url>/2021/01/12/21-01-12_%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<p>最长公共前缀 14<br>编写一个函数来查找字符串数组中的最长公共前缀。 如果不存在公共前缀，返回空字符串<br>输入: [“flower”,”flow”,”flight”], 输出: “fl”<br>输入: [“dog”,”racecar”,”car”], 输出: “”, 解释: 输入不存在公共前缀</p>
<a id="more"></a>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longestCommonPrefix</span>(<span class="params">strs</span>) -&gt; str:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> strs:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">    res = strs[-<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(strs) - <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> strs[i].startswith(res):</span><br><span class="line">            res = res[:-<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">strs = [<span class="string">&quot;fliower&quot;</span>,<span class="string">&quot;fliow&quot;</span>,<span class="string">&quot;flight&quot;</span>]</span><br><span class="line"><span class="comment"># strs = [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]</span></span><br><span class="line">print(longestCommonPrefix(strs))</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>CODING</category>
      </categories>
      <tags>
        <tag>子串</tag>
      </tags>
  </entry>
  <entry>
    <title>最长子序列相关</title>
    <url>/2021/01/12/21-01-12_%E6%9C%80%E9%95%BF%E5%AD%90%E5%BA%8F%E5%88%97%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<p>最长回文子序列长度 516<br>给定一个字符串 s ，找到其中最长的回文子序列，并返回该序列的长度。可以假设 s 的最大长度为 1000<br>输入: “bbbab”, 输出: 4, 一个可能的最长回文子序列为 “bbbb”。<br>输入: cbbd”, 输出: 2, 一个可能的最长回文子序列为 “bb”。</p>
<p>最长公共子序列长度 1143<br>给定两个字符串text1和text2，返回这两个字符串的最长公共子序列的长度<br>一个字符串的子序列是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串<br>例如，”ace” 是 “abcde” 的子序列，但 “aec” 不是 “abcde” 的子序列。<br>两个字符串的「公共子序列」是这两个字符串所共同拥有的子序列。若这两个字符串没有公共子序列，则返回 0<br>输入：text1 = “abcde”, text2 = “ace” , 输出：3, 解释：最长公共子序列是 “ace”，它的长度为 3。<br>输入：text1 = “abc”, text2 = “abc”, 输出：3, 解释：最长公共子序列是 “abc”，它的长度为 3。<br>输入：text1 = “abc”, text2 = “def”, 输出：0, 解释：两个字符串没有公共子序列，返回 0。</p>
<a id="more"></a>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longestPalindromeSubseq</span>(<span class="params">s</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    dp[i][j] i 到 j 的最长回文字序列的长度</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    length = <span class="built_in">len</span>(s)</span><br><span class="line">    dp = [[<span class="number">0</span>] * length <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(length)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length):</span><br><span class="line">        dp[i][i] = <span class="number">1</span>    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>, length):</span><br><span class="line">            <span class="keyword">if</span> s[i] == s[j]:</span><br><span class="line">                dp[i][j] = dp[i+<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">2</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(dp[i][j-<span class="number">1</span>], dp[i+<span class="number">1</span>][j])</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][length - <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">s = <span class="string">&quot;bbbab&quot;</span></span><br><span class="line">longestPalindromeSubseq(s)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longestCommonSubsequence</span>(<span class="params">text1: <span class="built_in">str</span>, text2: <span class="built_in">str</span></span>) -&gt; int:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    dp[i][j]：text1 前i位 与 text2 前j位 的最长公共子序列长度</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    m, n = <span class="built_in">len</span>(text1), <span class="built_in">len</span>(text2)</span><br><span class="line">    dp = [[<span class="number">0</span>] * (n + <span class="number">1</span>)] * (m + <span class="number">1</span>)</span><br><span class="line">    <span class="comment"># dp = [[0] * (n + 1) for _ in range(m + 1)]</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> text1[i - <span class="number">1</span>] == text2[j - <span class="number">1</span>]:</span><br><span class="line">                dp[i][j] = <span class="number">1</span> + dp[i - <span class="number">1</span>][j - <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>])</span><br><span class="line">    <span class="keyword">return</span> dp[-<span class="number">1</span>][-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">text1 = <span class="string">&quot;abcde&quot;</span></span><br><span class="line">text2 = <span class="string">&quot;ace&quot;</span> </span><br><span class="line">longestCommonSubsequence(text1, text2)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>CODING</category>
        <category>dp</category>
      </categories>
      <tags>
        <tag>子序列</tag>
      </tags>
  </entry>
  <entry>
    <title>电话号码字母组合</title>
    <url>/2021/01/14/21-01-14_%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/</url>
    <content><![CDATA[<p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。 给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母<br>输入：”23”, 输出：[“ad”, “ae”, “af”, “bd”, “be”, “bf”, “cd”, “ce”, “cf”]</p>
<a id="more"></a>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">letterCombinations</span>(<span class="params">digits: <span class="built_in">str</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">res, index, path, mapper</span>):</span></span><br><span class="line">        <span class="comment"># 结束条件</span></span><br><span class="line">        <span class="keyword">if</span> index == <span class="built_in">len</span>(digits):</span><br><span class="line">            <span class="keyword">if</span> path != <span class="string">&#x27;&#x27;</span>:</span><br><span class="line">                res.append(path)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="comment"># 做选择，for 代替了 选择、撤销选择的过程</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> mapper[digits[index]]:</span><br><span class="line">            dfs(res, index + <span class="number">1</span>, path + j, mapper)</span><br><span class="line">    </span><br><span class="line">    mapper = &#123;<span class="string">&#x27;2&#x27;</span>: <span class="string">&#x27;abc&#x27;</span>, <span class="string">&#x27;3&#x27;</span>: <span class="string">&#x27;def&#x27;</span>, <span class="string">&#x27;4&#x27;</span>: <span class="string">&#x27;ghi&#x27;</span>, <span class="string">&#x27;5&#x27;</span>: <span class="string">&#x27;jkl&#x27;</span>, <span class="string">&#x27;6&#x27;</span>: <span class="string">&#x27;mno&#x27;</span>, <span class="string">&#x27;7&#x27;</span>: <span class="string">&#x27;pqrs&#x27;</span>, </span><br><span class="line">              <span class="string">&#x27;8&#x27;</span>: <span class="string">&#x27;tuv&#x27;</span>, <span class="string">&#x27;9&#x27;</span>: <span class="string">&#x27;wxyz&#x27;</span>&#125;</span><br><span class="line">    res = []</span><br><span class="line">    dfs(res, <span class="number">0</span>, <span class="string">&#x27;&#x27;</span>, mapper)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">digits = <span class="string">&quot;22&quot;</span></span><br><span class="line">print(letterCombinations(digits))</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>CODING</category>
        <category>递归</category>
        <category>回溯_dfs</category>
      </categories>
  </entry>
  <entry>
    <title>矩阵中是否存在路径</title>
    <url>/2021/01/18/21-01-18_%E7%9F%A9%E9%98%B5%E4%B8%AD%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子</p>
<a id="more"></a>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hasPath</span>(<span class="params">matrix, rows, cols, path</span>):</span></span><br><span class="line">    <span class="comment"># write code here</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">row, col, size</span>):</span></span><br><span class="line">        <span class="keyword">if</span> size == <span class="built_in">len</span>(path):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> (r, c) <span class="keyword">in</span> [(row - <span class="number">1</span>, col), (row + <span class="number">1</span>, col), (row, col - <span class="number">1</span>), (row, col + <span class="number">1</span>)]:</span><br><span class="line">            <span class="keyword">if</span> <span class="number">0</span> &lt;= r &lt;= rows - <span class="number">1</span> <span class="keyword">and</span> <span class="number">0</span> &lt;= c &lt;= cols - <span class="number">1</span> <span class="keyword">and</span> board[r][c] == path[size]:</span><br><span class="line">                tmp, board[r][c] = board[r][c], <span class="literal">None</span></span><br><span class="line">                <span class="keyword">if</span> dfs(r, c, size + <span class="number">1</span>):</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                board[r][c] = tmp</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    board = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(rows):</span><br><span class="line">        board.append(<span class="built_in">list</span>(matrix[cols * i: cols * (i + <span class="number">1</span>)]))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(rows):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(cols):</span><br><span class="line">            <span class="keyword">if</span> board[i][j] == path[<span class="number">0</span>]:</span><br><span class="line">                tmp, board[i][j] = board[i][j], <span class="literal">None</span></span><br><span class="line">                <span class="keyword">if</span> dfs(i, j, <span class="number">1</span>):</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                board[i][j] = tmp</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">matrix = <span class="string">&quot;ABCESFCSADEE&quot;</span></span><br><span class="line">rows, cols = <span class="number">3</span>,<span class="number">4</span></span><br><span class="line">path = <span class="string">&quot;SEE&quot;</span></span><br><span class="line">print(hasPath(matrix, rows, cols, path))</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>CODING</category>
        <category>回溯_dfs</category>
      </categories>
  </entry>
  <entry>
    <title>机器人运动范围</title>
    <url>/2021/01/19/21-01-19_%E6%9C%BA%E5%99%A8%E4%BA%BA%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/</url>
    <content><![CDATA[<p>地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？<br>输入：threshold, rows, cols = 5,10,10， 输出：21 【6 + 5 + 4 + 3 + 2 + 1】</p>
<a id="more"></a>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">movingCount</span>(<span class="params">threshold, rows, cols</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cal_sum</span>(<span class="params">num</span>):</span></span><br><span class="line">        summ = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> num:</span><br><span class="line">            summ += num % <span class="number">10</span></span><br><span class="line">            num //= <span class="number">10</span></span><br><span class="line">        <span class="keyword">return</span> summ</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">check</span>(<span class="params">threshold, row, col, visited</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="number">0</span> &lt;= row &lt;= rows - <span class="number">1</span> <span class="keyword">and</span> <span class="number">0</span> &lt;= col &lt;= cols - <span class="number">1</span> <span class="keyword">and</span> <span class="keyword">not</span> visited[row][col]\</span><br><span class="line">            <span class="keyword">and</span> cal_sum(row) + cal_sum(col) &lt;= threshold:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">count_</span>(<span class="params">threshold, row, col, visited</span>):</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> check(threshold, row, col, visited):</span><br><span class="line">            visited[row][col] = <span class="literal">True</span></span><br><span class="line">            count = <span class="number">1</span> + count_(threshold, row - <span class="number">1</span>, col, visited)\</span><br><span class="line">                    + count_(threshold, row + <span class="number">1</span>, col, visited)\</span><br><span class="line">                    + count_(threshold, row, col - <span class="number">1</span>, visited)\</span><br><span class="line">                    + count_(threshold, row, col + <span class="number">1</span>, visited)</span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line">    </span><br><span class="line">    visited = [[<span class="literal">False</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(cols)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(rows)]</span><br><span class="line">    count = count_(threshold, <span class="number">0</span>, <span class="number">0</span>, visited)</span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line"></span><br><span class="line">threshold, rows, cols = <span class="number">5</span>, <span class="number">10</span>, <span class="number">10</span></span><br><span class="line">print(movingCount(threshold, rows, cols))</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>CODING</category>
        <category>回溯_dfs</category>
      </categories>
  </entry>
  <entry>
    <title>相同的/对称的二叉树</title>
    <url>/2021/01/20/21-01-20_%E7%9B%B8%E5%90%8C%E7%9A%84_%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<p>相同的树：如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的<br>对称的树：如果一个二叉树同此二叉树的镜像是相同的，定义其为对称的<br> <a id="more"></a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isSameTree</span>(<span class="params">p, q</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> p <span class="keyword">and</span> <span class="keyword">not</span> q:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> p <span class="keyword">and</span> q:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> q <span class="keyword">and</span> p:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> p.val != q.val:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> isSameTree(p.left, q.left) <span class="keyword">and</span> isSameTree(p.right, q.right)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isSymmetrical</span>(<span class="params">pRoot</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">recursive</span>(<span class="params">left, right</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> left <span class="keyword">and</span> <span class="keyword">not</span> right:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> left <span class="keyword">or</span> <span class="keyword">not</span> right:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> left.val != right.val:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> recursive(left.left, right.right) <span class="keyword">and</span> recursive(left.right, right.left)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> pRoot:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> recursive(pRoot.left, pRoot.right)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>CODING</category>
        <category>递归</category>
        <category>树</category>
      </categories>
  </entry>
  <entry>
    <title>二叉树最近公共祖先</title>
    <url>/2021/01/20/21-01-20_%E4%BA%8C%E5%8F%89%E6%A0%91%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</url>
    <content><![CDATA[<p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。 最近公共祖先的定义为：对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且x的深度尽可能大（一个节点也可以是它自己的祖先）</p>
<a id="more"></a>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span>(<span class="params">root, p, q</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    case1: 如果 p 和 q 都在以 root 为根的树中，函数返回的是 p 和 q 的最近公共祖先节点;</span></span><br><span class="line"><span class="string">    case2: 如果 p 和 q 都不在以 root 为根的树中, 函数理所当然地返回 None;</span></span><br><span class="line"><span class="string">    case3: 如果 p 和 q 只有一个存在于 root 为根的树中, 函数就会返回那个节点;</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">in</span> (<span class="literal">None</span>, p, q):</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    left = lowestCommonAncestor(root.left, p, q)</span><br><span class="line">    right = lowestCommonAncestor(root.right, p, q)</span><br><span class="line">    <span class="comment"># left != None and right != None</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> left <span class="keyword">and</span> <span class="keyword">not</span> right: </span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    <span class="keyword">return</span> left <span class="keyword">or</span> right</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>CODING</category>
        <category>递归</category>
        <category>树</category>
      </categories>
  </entry>
  <entry>
    <title>合法的二叉搜索树</title>
    <url>/2021/01/20/21-01-20_%E5%90%88%E6%B3%95%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    <content><![CDATA[<p>给定一个二叉树，判断其是否是一个有效的二叉搜索树。 假设一个二叉搜索树具有如下特征： 节点的左子树只包含小于当前节点的数。 节点的右子树只包含大于当前节点的数。 所有左子树和右子树自身必须也是二叉搜索树</p>
<a id="more"></a>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isValidBST</span>(<span class="params">root</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">root, minn, maxx</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> minn &lt; root.val &lt; maxx:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> dfs(root.left, minn, root.val) <span class="keyword">and</span> dfs(root.right, root.val, maxx)</span><br><span class="line">    min_val, max_val = <span class="built_in">float</span>(<span class="string">&#x27;-inf&#x27;</span>), <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> dfs(root, min_val, max_val)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>CODING</category>
        <category>树</category>
        <category>回溯_dfs</category>
      </categories>
  </entry>
  <entry>
    <title>括号生成</title>
    <url>/2021/01/20/21-01-20_%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/</url>
    <content><![CDATA[<p>数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合<br>输入：n = 3, 输出：[“((()))”,  “(()())”,  “(())()”,  “()(())”,  “()()()” ]</p>
<a id="more"></a>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generateParenthesis</span>(<span class="params">n: <span class="built_in">int</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span>(<span class="params">left, right, res, track</span>):</span></span><br><span class="line">        <span class="keyword">if</span> right &lt; left:</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        <span class="keyword">elif</span> left &lt; <span class="number">0</span> <span class="keyword">or</span> right &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">elif</span> left == <span class="number">0</span> <span class="keyword">and</span> right == <span class="number">0</span>:</span><br><span class="line">            res.append(track[:])</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">        track += <span class="string">&#x27;(&#x27;</span></span><br><span class="line">        backtrack(left - <span class="number">1</span>, right, res, track)</span><br><span class="line">        track = track[:-<span class="number">1</span>] <span class="comment"># list.pop()</span></span><br><span class="line">        </span><br><span class="line">        track += <span class="string">&#x27;)&#x27;</span></span><br><span class="line">        backtrack(left, right - <span class="number">1</span>, res, track)</span><br><span class="line">        track = track[:-<span class="number">1</span>]</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    res = []</span><br><span class="line">    track = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    backtrack(n, n, res, track)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">n = <span class="number">2</span></span><br><span class="line">print(generateParenthesis(n))</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>CODING</category>
        <category>回溯_dfs</category>
      </categories>
  </entry>
  <entry>
    <title>贺炜语录</title>
    <url>/2021/01/22/21-01-22_%E8%B4%BA%E7%82%9C%E8%AF%AD%E5%BD%95/</url>
    <content><![CDATA[<p>生活不可能像你想象得那么好,但也不会像你想象得那么糟。人的脆弱和坚强都超乎自己的想象。有时,我可能脆弱得一句话就泪流满面,有时,也发现自己咬着牙走了很长的路。</p>
<p>人生当中成功只是一时的，失败却是主旋律，但是如何面对失败却把人分成了不同的样子。有的人会被失败击垮，有的人会不断爬起来继续向前，澳大利亚队是如此，西班牙队也是如此。我想真正的成熟应该并不是追求完美，而是直面自己的缺憾，这才是生活的本质。罗曼-罗兰说过：“这个世界上只有一种真正的英雄主义，那就是认清生活的真相并且仍然热爱它。”</p>
<a id="more"></a>
<p>胜不妄喜,败不惶馁,胸有激雷而面如平湖者,可拜上将军。</p>
<p>94年的时候，我还是个中学生，听到马拉多纳禁赛的消息，我当时认为马拉多纳有一天还会回来的。但是，生活当中往往就是这样，一件不经意的小事，经常就是命运的转折，一次看似普通的再见，其实就是永别！缘分就在那一个瞬间戛然而止。</p>
<p>爱本身并没有错，爱谁都是自由，爱强者更是人类的天性。不过因为自己所爱的事物强大，就幻想自己也强大了，甚至觉得爱其他事物的人都已经被踩在脚下了，这就是病态，一种弱者的病态。此道理，适合所有人。</p>
<p>人的一生中最光辉的一天，并非是功成名就那天，而是从悲叹与绝望中产生对人生的挑战、以勇敢迈向意志那天。我们也以这句福楼拜的名言，送别即将离去的法国队，希望法国队重拾勇气，重振辉煌！</p>
]]></content>
      <categories>
        <category>文学</category>
        <category>贺炜</category>
      </categories>
  </entry>
  <entry>
    <title>全排列</title>
    <url>/2021/01/22/21-01-22_%E5%85%A8%E6%8E%92%E5%88%97/</url>
    <content><![CDATA[<p>输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则按字典序打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。输入描述:输入一个字符串,长度不超过9(可能有字符重复),字符只包括大小写字母。<br>输入: “ab”, 返回值: [“ab”,”ba”]</p>
<a id="more"></a>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Permutation</span>(<span class="params">ss</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span>(<span class="params">ss, res, track, used</span>):</span></span><br><span class="line">        <span class="comment"># 满足条件，终止</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(track) == <span class="built_in">len</span>(ss):</span><br><span class="line">            res.append(track[:])</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(ss)):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> used[i]:</span><br><span class="line">                used[i] = <span class="literal">True</span></span><br><span class="line">                <span class="comment"># 做选择</span></span><br><span class="line">                track += ss[i]</span><br><span class="line">                backtrack(ss, res, track, used)</span><br><span class="line">                used[i] = <span class="literal">False</span></span><br><span class="line">                <span class="comment"># 撤销选择</span></span><br><span class="line">                track = track[:-<span class="number">1</span>]</span><br><span class="line">    res = []</span><br><span class="line">    used = [<span class="literal">False</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(ss))]</span><br><span class="line">    backtrack(ss, res, <span class="string">&#x27;&#x27;</span>, used)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sorted</span>(<span class="built_in">set</span>(res))</span><br><span class="line"></span><br><span class="line">ss = <span class="string">&quot;ab&quot;</span></span><br><span class="line">print(Permutation(ss))</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>CODING</category>
        <category>回溯_dfs</category>
      </categories>
  </entry>
</search>
