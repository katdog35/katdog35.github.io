<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>数组的有序拆分</title>
    <url>/2020/08/25/20-08-25_%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%89%E5%BA%8F%E6%8B%86%E5%88%86/</url>
    <content><![CDATA[<p>实现一个数组的有序拆分<br>给定一个浮点数组及 2个阀值l 和 h，l &lt; h<br>对数组排序满足，数组左边均小于l，右边均大于h，中间部分在[l, h]之间<br>时间复杂度O(N), 额外空间复杂度O(1)</p>
<a id="more"></a>
<p>```python<br>def splitArr(arr, l, h):<br>    def f(arr, l):<br>        length = len(arr)<br>        if length == 0:<br>            return<br>        start = 0<br>        end = length - 1<br>        cur = 0<br>        while cur &lt;= end:<br>            if arr[cur] &lt; l:<br>                arr[cur], arr[start] = arr[start], arr[cur]<br>                start += 1<br>                cur += 1<br>            elif arr[cur] == l:<br>                cur += 1<br>            elif arr[cur] &gt; l:<br>                arr[cur], arr[end] = arr[end], arr[cur]<br>                end -= 1<br>    f(arr, l)<br>    f(arr, h)<br>    return arr</p>
<p>arr = [1,2,5,4,3,7,2,5,1,9,3,2,8]<br>print(splitArr(arr, 4, 5))```</p>
]]></content>
      <categories>
        <category>CODING</category>
        <category>双指针</category>
      </categories>
      <tags>
        <tag>百度</tag>
      </tags>
  </entry>
  <entry>
    <title>只出现一次的字符</title>
    <url>/2020/12/20/20-12-20_%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6/</url>
    <content><![CDATA[<p>数组中只有一个单个元素，其他元素成对，找到只出现一次的元素</p>
<ul>
<li>成对出现，异或 ^，O（N）</li>
<li>成对连续出现，根据奇偶性二分</li>
</ul>
<a id="more"></a>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bs</span>(<span class="params">arr</span>):</span></span><br><span class="line">    left, right = <span class="number">0</span>, <span class="built_in">len</span>(arr) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> left &lt; right:</span><br><span class="line">        mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> mid - <span class="number">1</span> &gt;= left <span class="keyword">and</span> mid + <span class="number">1</span> &lt;= right <span class="keyword">and</span> arr[mid] != arr[mid - <span class="number">1</span>] <span class="keyword">and</span> arr[mid] != arr[mid + <span class="number">1</span>]:</span><br><span class="line">            <span class="keyword">return</span> mid, arr[mid]</span><br><span class="line">        <span class="keyword">elif</span> mid + <span class="number">1</span> &lt;= right <span class="keyword">and</span> arr[mid] == arr[mid + <span class="number">1</span>]:</span><br><span class="line">            length = mid + <span class="number">1</span> - left + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> length % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">                right = mid - <span class="number">1</span> <span class="comment"># mid = mid + 1 且为 mid + 1 左边长度为奇数, right -&gt; mid - 1</span></span><br><span class="line">            <span class="keyword">else</span>: </span><br><span class="line">                left = mid + <span class="number">2</span>  <span class="comment"># mid = mid + 1 且为 mid + 1 右边长度为奇数, right -&gt; mid + 2</span></span><br><span class="line">                <span class="comment"># left = mid</span></span><br><span class="line">        <span class="keyword">elif</span> mid - <span class="number">1</span> &gt;= left <span class="keyword">and</span> arr[mid] == arr[mid - <span class="number">1</span>]:</span><br><span class="line">            length = mid - left + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> length % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">                right = mid - <span class="number">2</span> <span class="comment"># mid - 1 = mid 且为 mid 左边长度为奇数, right -&gt; mid -2</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left = mid + <span class="number">1</span> <span class="comment"># mid - 1 = mid 且为mid 右边长度为奇数, right -&gt; mid + 1</span></span><br><span class="line">    <span class="comment"># left = right</span></span><br><span class="line">    <span class="comment"># 【1，2，2】;【1，1，2】的情况</span></span><br><span class="line">    <span class="keyword">return</span> left, arr[left]</span><br><span class="line"> </span><br><span class="line">arr = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">arr = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">5</span>]</span><br><span class="line">print(bs(arr))</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>CODING</category>
        <category>二分</category>
      </categories>
      <tags>
        <tag>快手</tag>
        <tag>头条</tag>
      </tags>
  </entry>
  <entry>
    <title>柱状图中的最大矩形</title>
    <url>/2020/12/20/20-12-20_%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2/</url>
    <content><![CDATA[<p>给定一个仅包含 0 和 1 的二维二进制矩阵，找出只包含 1 的最大矩形，并返回其面积<br>输入:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">    [<span class="string">&quot;1&quot;</span>,<span class="string">&quot;0&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;0&quot;</span>,<span class="string">&quot;0&quot;</span>],</span><br><span class="line">    [<span class="string">&quot;1&quot;</span>,<span class="string">&quot;0&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;1&quot;</span>],</span><br><span class="line">    [<span class="string">&quot;1&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;1&quot;</span>],</span><br><span class="line">    [<span class="string">&quot;1&quot;</span>,<span class="string">&quot;0&quot;</span>,<span class="string">&quot;0&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;0&quot;</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>输出: 6 </p>
<a id="more"></a>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">largestRectangleArea2</span>(<span class="params">self, heights</span>) -&gt; int:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    暴力法 O(N^2), 以 heights[i] 的高度为高，求左右满足的宽</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    lg = <span class="built_in">len</span>(heights)</span><br><span class="line">    maxx = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(lg):</span><br><span class="line">        tmp = heights[i]</span><br><span class="line">        left, right = i, i</span><br><span class="line">        <span class="keyword">while</span> left &gt; <span class="number">0</span> <span class="keyword">and</span> heights[left - <span class="number">1</span>] &gt;= heights[i]:</span><br><span class="line">            left -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> right &lt; lg - <span class="number">1</span> <span class="keyword">and</span> heights[right + <span class="number">1</span>] &gt;= heights[i]:</span><br><span class="line">            right += <span class="number">1</span></span><br><span class="line">        maxx = <span class="built_in">max</span>(tmp * (right - left + <span class="number">1</span>), maxx)</span><br><span class="line">    <span class="keyword">return</span> maxx</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">largestRectangleArea</span>(<span class="params">heights</span>) -&gt; int:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    单调栈, stack 递增</span></span><br><span class="line"><span class="string">    cur 比 stack[-1]大，入栈; </span></span><br><span class="line"><span class="string">    cur 比 stack[-1]小，依次出栈至 stack[-1]小于cur</span></span><br><span class="line"><span class="string">    以出栈元素的值为高，求宽，更新最值</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    heights.append(<span class="number">0</span>) <span class="comment"># 判断最后一个元素为高的情况</span></span><br><span class="line">    lg = <span class="built_in">len</span>(heights)</span><br><span class="line">    stack = [<span class="number">0</span>]</span><br><span class="line">    maxx = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, lg):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> stack <span class="keyword">and</span> heights[stack[-<span class="number">1</span>]] &lt;= heights[i]:</span><br><span class="line">            stack.append(i)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> heights[stack[-<span class="number">1</span>]] &gt;= heights[i]:</span><br><span class="line">                h = heights[stack[-<span class="number">1</span>]]</span><br><span class="line">                stack.pop()</span><br><span class="line">                <span class="comment"># stack 为空，说明当前height[i] 小于 i之前所有的值</span></span><br><span class="line">                 </span><br><span class="line">                w = i <span class="keyword">if</span> <span class="keyword">not</span> stack <span class="keyword">else</span> i - (stack[-<span class="number">1</span>] + <span class="number">1</span>)</span><br><span class="line">                maxx = <span class="built_in">max</span>(maxx, h*w)</span><br><span class="line">            stack.append(i)</span><br><span class="line">    <span class="keyword">return</span> maxx</span><br><span class="line"><span class="comment"># i=3 结束时，stack = [0,3]；i=4, height[4]=0时，w = i - (0 + 1) = 3</span></span><br><span class="line">heights = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>] </span><br><span class="line">print(largestRectangleArea(heights))</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>CODING</category>
        <category>单调栈</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的直径</title>
    <url>/2020/12/23/20-12-22_%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/</url>
    <content><![CDATA[<p>给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点<br>示例 :<br>给定二叉树<br>            1<br>          / <br>         2   3<br>        / \<br>       4   5<br>返回 3, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]</p>
<a id="more"></a>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">diameterOfBinaryTree</span>(<span class="params">root</span>) -&gt; int:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">root</span>):</span></span><br><span class="line">        <span class="comment"># 返回: 以root 为根结点的最长路径的最大节点个数</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="comment"># focus on one node</span></span><br><span class="line">        left = dfs(root.left)</span><br><span class="line">        right = dfs(root.right)</span><br><span class="line">        <span class="keyword">global</span> node_nums</span><br><span class="line">        node_nums = <span class="built_in">max</span>(node_nums, left + right + <span class="number">1</span>)</span><br><span class="line">        <span class="comment"># 左右子树只能贡献一边，向上递归</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(left, right) + <span class="number">1</span> </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">global</span> node_nums</span><br><span class="line">    node_nums = <span class="number">1</span></span><br><span class="line">    dfs(root)</span><br><span class="line">    <span class="keyword">return</span> node_nums - <span class="number">1</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>CODING</category>
        <category>树</category>
      </categories>
      <tags>
        <tag>头条</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>sqrt(x)</title>
    <url>/2020/12/22/20-12-22_%E5%BC%80%E5%B9%B3%E6%96%B9/</url>
    <content><![CDATA[<p>给定浮点数x, 求sqrt(x)</p>
<a id="more"></a>

<h1 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h1><ul>
<li>当 x&lt;1 时，注意左右边界<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sqrt</span>(<span class="params">x, error</span>):</span></span><br><span class="line">    <span class="comment"># 二分</span></span><br><span class="line">    <span class="keyword">if</span> x &lt;= <span class="number">1</span>:</span><br><span class="line">        left, right = x, <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        left, right = <span class="number">1</span>, x</span><br><span class="line">    <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">        mid = left + (right - left) / <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">abs</span>(mid * mid - x) &lt;= error:</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        <span class="keyword">elif</span> mid * mid - x &gt; <span class="number">0</span>:</span><br><span class="line">            right = mid</span><br><span class="line">        <span class="keyword">elif</span> mid * mid - x &lt; <span class="number">0</span>:</span><br><span class="line">            left = mid</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="牛顿法"><a href="#牛顿法" class="headerlink" title="牛顿法"></a>牛顿法</h1><ul>
<li>切线是曲线的近似拟合<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sqrt</span>(<span class="params">target, error</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    f(x) = x^2 - target = 0</span></span><br><span class="line"><span class="string">    f&#x27;(x) = 2 * x</span></span><br><span class="line"><span class="string">    切线方程： 2 * x * (x_hat - x) + f(x)</span></span><br><span class="line"><span class="string">    x_hat = (x + target / x) / 2</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    x = target</span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">abs</span>(x * x - target) &gt; error:</span><br><span class="line">        x = (x + target / x) / <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>CODING</category>
        <category>二分</category>
      </categories>
      <tags>
        <tag>快手</tag>
        <tag>好未来</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>打家劫舍I/II/III</title>
    <url>/2020/12/22/20-12-22_%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/</url>
    <content><![CDATA[<p>I<br>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。</p>
<p>II<br>这个地方所有的房屋都围成一圈，这意味着第一个房屋和最后一个房屋是紧挨着的</p>
<p>III<br>这个地方的所有房屋的排列类似于一棵二叉树。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警</p>
<a id="more"></a>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rob1</span>(<span class="params">arr</span>):</span></span><br><span class="line">    size = <span class="built_in">len</span>(arr)</span><br><span class="line">    <span class="keyword">if</span> size == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> size == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> arr[<span class="number">0</span>]</span><br><span class="line">    dp = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(size)]</span><br><span class="line">    dp[<span class="number">0</span>], dp[<span class="number">1</span>] = arr[<span class="number">0</span>], <span class="built_in">max</span>(arr[<span class="number">0</span>], arr[<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, size):</span><br><span class="line">        dp[i] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>], dp[i - <span class="number">2</span>] + arr[i])</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(dp)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rob2</span>(<span class="params">arr</span>):</span></span><br><span class="line">    size = <span class="built_in">len</span>(arr)</span><br><span class="line">    <span class="keyword">if</span> size == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> size == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> arr[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(rob1(arr[:-<span class="number">1</span>]), rob1(arr[<span class="number">1</span>:]))</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rob3</span>(<span class="params">root</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">node</span>):</span></span><br><span class="line">        <span class="comment"># return node 偷 / 不偷 能获取的最大值</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>, <span class="number">0</span> <span class="comment"># 偷， 不偷</span></span><br><span class="line">        left_res = dfs(node.left)</span><br><span class="line">        right_res = dfs(node.right)</span><br><span class="line">        <span class="comment"># 当前 node 偷</span></span><br><span class="line">        res1 = left_res[<span class="number">1</span>] + right_res[<span class="number">1</span>] + node.val</span><br><span class="line">        <span class="comment"># 当前 node 不偷</span></span><br><span class="line">        res2 = <span class="built_in">max</span>(left_res) + <span class="built_in">max</span>(right_res)</span><br><span class="line">        <span class="keyword">return</span> res1, res2</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(dfs(root))</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>CODING</category>
        <category>dp</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>数组中的逆序对</title>
    <url>/2020/12/23/20-12-22_%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9/</url>
    <content><![CDATA[<p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P</p>
<a id="more"></a>

<h1 id="暴力法"><a href="#暴力法" class="headerlink" title="暴力法"></a>暴力法</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reversePairs1</span>(<span class="params">nums</span>):</span></span><br><span class="line">    <span class="comment"># O(N^2)</span></span><br><span class="line">    ans, size = <span class="number">0</span>, <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="keyword">if</span> size &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(size - <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i + <span class="number">1</span>, size):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt; nums[j]:</span><br><span class="line">                ans += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<h1 id="归并排序应用"><a href="#归并排序应用" class="headerlink" title="归并排序应用"></a>归并排序应用</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reversePairs2</span>(<span class="params">nums</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge_sort</span>(<span class="params">nums</span>):</span></span><br><span class="line">        <span class="comment"># 递归终止条件</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums) &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> nums</span><br><span class="line">        mid = <span class="built_in">len</span>(nums) // <span class="number">2</span></span><br><span class="line">        l_res = merge_sort(nums[ :mid])</span><br><span class="line">        r_res = merge_sort(nums[mid: ])</span><br><span class="line">        <span class="keyword">return</span> merge(l_res, r_res)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">left, right</span>):</span></span><br><span class="line">        lst = []</span><br><span class="line">        i, j = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(left) <span class="keyword">and</span> j &lt; <span class="built_in">len</span>(right):</span><br><span class="line">            <span class="keyword">if</span> left[i] &lt;= right[j]:</span><br><span class="line">                lst.append(left[i])</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">global</span> ans</span><br><span class="line">                ans += <span class="built_in">len</span>(left) - i</span><br><span class="line">                lst.append(right[j])</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">        lst.extend(left[i:])</span><br><span class="line">        lst.extend(right[j:])</span><br><span class="line">        <span class="keyword">return</span> lst</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">global</span> ans</span><br><span class="line">    ans = <span class="number">0</span></span><br><span class="line">    nums_sorted = merge_sort(nums)</span><br><span class="line">    <span class="keyword">return</span> nums_sorted, ans</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>CODING</category>
        <category>排序</category>
      </categories>
      <tags>
        <tag>头条</tag>
        <tag>排序应用</tag>
      </tags>
  </entry>
  <entry>
    <title>最长有效括号长度</title>
    <url>/2020/12/22/20-12-22_%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7%E9%95%BF%E5%BA%A6/</url>
    <content><![CDATA[<p>给定一个只包含 ‘(‘ 和 ‘)’ 的字符串，找出最长的包含有效括号的子串的长度<br>示例 1:<br>输入: “(()”<br>输出: 2<br>解释: 最长有效括号子串为 “()”</p>
<p>示例 2:<br>输入: “)()())”<br>输出: 4<br>解释: 最长有效括号子串为 “()()”</p>
<a id="more"></a>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longestValidParentheses</span>(<span class="params">s: <span class="built_in">str</span></span>) -&gt; int:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    dp[i]: 以s[i]结尾的最长有效括号子串长度</span></span><br><span class="line"><span class="string">    if s[i] = &#x27;(&#x27;:</span></span><br><span class="line"><span class="string">        dp[i] = 0</span></span><br><span class="line"><span class="string">    else: # s[i] = &#x27;)&#x27;</span></span><br><span class="line"><span class="string">        if s[i - 1] = &#x27;(&#x27;:</span></span><br><span class="line"><span class="string">            dp[i] = dp[i - 1] + 2 </span></span><br><span class="line"><span class="string">        else: # s[i - 1] = &#x27;)&#x27;</span></span><br><span class="line"><span class="string">            if s[i - dp[i - 1] - 1] = &#x27;(&#x27;:</span></span><br><span class="line"><span class="string">                dp[i] = 2 + dp[i - 1] + dp[i - dp[i - 1] - 1 - 1]</span></span><br><span class="line"><span class="string">    注意可能越界, i &gt; 0，i - dp[i - 1] - 1 &gt;= 0</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    dp = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s))]</span><br><span class="line">    ans = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">        <span class="keyword">if</span> s[i] == <span class="string">&#x27;)&#x27;</span>:<span class="comment"># 只考虑以&#x27;)&#x27;结尾的子串</span></span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> s[i - <span class="number">1</span>] == <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">                dp[i] = dp[i - <span class="number">2</span>] + <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> s[i - <span class="number">1</span>] == <span class="string">&#x27;)&#x27;</span>:</span><br><span class="line">                <span class="keyword">if</span> i - dp[i - <span class="number">1</span>] - <span class="number">1</span> &gt;= <span class="number">0</span> <span class="keyword">and</span> s[i - dp[i - <span class="number">1</span>] - <span class="number">1</span>] == <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">                    <span class="keyword">if</span> i - dp[i - <span class="number">1</span>] - <span class="number">2</span> &gt;= <span class="number">0</span>:<span class="comment"># 当前合法子串，前面还有子串的情况</span></span><br><span class="line">                        dp[i] = <span class="number">2</span> + dp[i - <span class="number">1</span>] + dp[i - dp[i - <span class="number">1</span>] - <span class="number">2</span>]</span><br><span class="line">                    <span class="keyword">else</span>: <span class="comment"># 当前合法子串，前面没有子串的情况</span></span><br><span class="line">                        dp[i] = <span class="number">2</span> + dp[i - <span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(dp)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longestValidParentheses2</span>(<span class="params">s: <span class="built_in">str</span></span>) -&gt; int:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    中心拓展法 def expand(l, r)</span></span><br><span class="line"><span class="string">    return [l, r]: 有效括号的左右边界</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    dic = &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">expand</span>(<span class="params">l, r</span>):</span></span><br><span class="line">        <span class="keyword">while</span> l &gt;= <span class="number">0</span> <span class="keyword">and</span> r &lt; <span class="built_in">len</span>(s) <span class="keyword">and</span> s[l] == <span class="string">&#x27;(&#x27;</span> <span class="keyword">and</span> s[r] == <span class="string">&#x27;)&#x27;</span>:</span><br><span class="line">            l -= <span class="number">1</span></span><br><span class="line">            r += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> l + <span class="number">1</span> - <span class="number">1</span> <span class="keyword">in</span> dic:</span><br><span class="line">            <span class="keyword">return</span> expand(dic[l + <span class="number">1</span> - <span class="number">1</span>], r - <span class="number">1</span>)</span><br><span class="line">        dic[r - <span class="number">1</span>] = l + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> [l + <span class="number">1</span>, r - <span class="number">1</span>]</span><br><span class="line">    </span><br><span class="line">    ans = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s) - <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> s[i] == <span class="string">&#x27;(&#x27;</span> <span class="keyword">and</span> s[i + <span class="number">1</span>] == <span class="string">&#x27;)&#x27;</span>:</span><br><span class="line">            l, r = expand(i, i + <span class="number">1</span>)</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, r - l + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longestValidParentheses3</span>(<span class="params">s</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    栈</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    q = []</span><br><span class="line">    start, ans = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">        <span class="keyword">if</span> s[i] == <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">            q.append(i)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> q: </span><br><span class="line">                start = i + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                q.pop()</span><br><span class="line">                <span class="keyword">if</span> q:</span><br><span class="line">                    ans = <span class="built_in">max</span>(ans, i - q[-<span class="number">1</span>])</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    ans = <span class="built_in">max</span>(ans, i - start + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>CODING</category>
        <category>dp</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>滴滴</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树镜像</title>
    <url>/2020/12/23/20-12-23_%E4%BA%8C%E5%8F%89%E6%A0%91%E9%95%9C%E5%83%8F/</url>
    <content><![CDATA[<p>完成一个函数，输入一个二叉树，该函数输出它的镜像。<br>例如输入：<br>   4<br>  / \<br>  2  7<br> / \ / \<br> 1 3 6 9<br>镜像输出：<br>  4<br> / \<br> 7  2<br>/ \ / \<br>9 6 3 1 </p>
<a id="more"></a>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mirrorTree1</span>(<span class="params">root</span>):</span></span><br><span class="line">    <span class="comment"># 递归</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    root.left, root.right = root.right, root.left</span><br><span class="line">    mirrorTree1(root.left)</span><br><span class="line">    mirrorTree1(root.right)</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mirrorTree2</span>(<span class="params">root</span>):</span></span><br><span class="line">    <span class="comment"># 非递归</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    queue = []</span><br><span class="line">    queue.append(root)</span><br><span class="line">    <span class="keyword">while</span> queue:</span><br><span class="line">        cur = queue.pop(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span> cur.left:</span><br><span class="line">            queue.append(cur.left)</span><br><span class="line">        <span class="keyword">if</span> cur.right:</span><br><span class="line">            queue.append(cur.right)</span><br><span class="line">        cur.left, cur.right = cur.right, cur.left</span><br><span class="line">    <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>CODING</category>
        <category>树</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>滑动窗口最大值</title>
    <url>/2020/12/22/20-12-22_%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC/</url>
    <content><![CDATA[<p>给定一个数组 nums 和滑动窗口的大小 k，请找出所有滑动窗口里的最大值<br>示例:<br>输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3<br>输出: [3,3,5,5,6,7]<br>解释:<br>    [1  3  -1] -3  5  3  6  7   =&gt; 3<br>    1 [3  -1  -3] 5  3  6  7    =&gt; 3<br>    1  3 [-1  -3  5] 3  6  7    =&gt; 5<br>    1  3  -1 [-3  5  3] 6  7    =&gt; 5<br>    1  3  -1  -3 [5  3  6] 7    =&gt; 6<br>    1  3  -1  -3  5 [3  6  7]   =&gt; 7<br>提示：你可以假设 k 总是有效的，在输入数组不为空的情况下，1 ≤ k ≤ 输入数组的大小</p>
<a id="more"></a>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxSlidingWindow</span>(<span class="params">nums, k</span>):</span></span><br><span class="line">    <span class="comment"># 暴力法， O(KN)</span></span><br><span class="line">    left, right = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    lst = []</span><br><span class="line">    <span class="keyword">while</span> right &lt;= <span class="built_in">len</span>(nums) - <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">while</span> right - left &lt; k:</span><br><span class="line">            right += <span class="number">1</span></span><br><span class="line">        lst.append(<span class="built_in">max</span>(nums[left: right]))</span><br><span class="line">        left += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> lst</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxSlidingWindow</span>(<span class="params">nums, k</span>):</span></span><br><span class="line">    <span class="comment"># 单调栈</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    res, stack = [], []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">        <span class="comment"># 窗口左边的元素弹出</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(stack) &gt; <span class="number">0</span> <span class="keyword">and</span> stack[<span class="number">0</span>] &lt;= i - k:</span><br><span class="line">            stack.pop(<span class="number">0</span>)</span><br><span class="line">        <span class="comment"># 维护栈内元素有序</span></span><br><span class="line">        <span class="keyword">while</span> stack <span class="keyword">and</span> nums[stack[-<span class="number">1</span>]] &lt; nums[i]:</span><br><span class="line">            stack.pop()</span><br><span class="line">        stack.append(i)</span><br><span class="line">        <span class="keyword">if</span> i &gt;= k - <span class="number">1</span>:</span><br><span class="line">            res.append(nums[stack[<span class="number">0</span>]])</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>CODING</category>
        <category>单调栈</category>
      </categories>
      <tags>
        <tag>头条</tag>
      </tags>
  </entry>
  <entry>
    <title>删除k个元素使整型字符串最小</title>
    <url>/2020/12/23/20-12-23_%E5%88%A0%E9%99%A4k%E4%B8%AA%E5%85%83%E7%B4%A0%E4%BD%BF%E6%95%B4%E5%9E%8B%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9C%80%E5%B0%8F/</url>
    <content><![CDATA[<p>给定一个整型string，删除k个元素后，使int(string)最小<br>例如，string=”32124”，k=2，输出 124；k=3，输出12</p>
<a id="more"></a>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_min_val</span>(<span class="params">str_nums, k</span>):</span></span><br><span class="line">    <span class="keyword">if</span> k == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">int</span>(str_nums)</span><br><span class="line">    <span class="keyword">while</span> k &gt; <span class="number">0</span>:</span><br><span class="line">        cur = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> cur &lt; <span class="built_in">len</span>(str_nums) - <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">if</span> str_nums[cur] &gt; str_nums[cur + <span class="number">1</span>]:</span><br><span class="line">                str_nums = str_nums[:cur] + str_nums[cur + <span class="number">1</span>:]</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur += <span class="number">1</span></span><br><span class="line">        str_nums = str_nums[:-<span class="number">1</span>] <span class="keyword">if</span> cur == <span class="built_in">len</span>(str_nums) - <span class="number">1</span> <span class="keyword">else</span> str_nums</span><br><span class="line">        k -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">int</span>(str_nums)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">str_nums = <span class="string">&#x27;32513479&#x27;</span></span><br><span class="line">k = <span class="number">2</span></span><br><span class="line">print(get_min_val(str_nums, k))</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>CODING</category>
      </categories>
      <tags>
        <tag>百度</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树中和为某一值的路径</title>
    <url>/2020/12/24/20-12-24_%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<p>输入一棵二叉树和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。从树的根节点开始往下一直到叶节点所经过的节点形成一条路径</p>
<a id="more"></a>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pathSum</span>(<span class="params">root, summ: <span class="built_in">int</span></span>):</span></span><br><span class="line">    res, path = [], []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">recur</span>(<span class="params">root, target</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        path.append(root.val)</span><br><span class="line">        target -= root.val</span><br><span class="line">        <span class="comment"># 如果满足条件【路径，且 和等于target】</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right <span class="keyword">and</span> <span class="built_in">sum</span>(path) == target:</span><br><span class="line">            res.append(path[:]) <span class="comment"># copy, 否则后面改变会影响前面的值</span></span><br><span class="line">        <span class="comment"># 不满足条件，递归</span></span><br><span class="line">        <span class="keyword">if</span> root.left:</span><br><span class="line">            recur(root.left, target)</span><br><span class="line">        <span class="keyword">if</span> root.right:</span><br><span class="line">            recur(root.right, target)</span><br><span class="line">        path.pop()</span><br><span class="line">    recur(root, summ)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>CODING</category>
        <category>树</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>把数组排成最小的数</title>
    <url>/2020/12/24/20-12-24_%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0/</url>
    <content><![CDATA[<p>输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。<br>示例 1:<br>输入: [10,2]<br>输出: “102” </p>
<p>示例 2:<br>输入: [3,30,34,5,9]<br>输出: “3033459”</p>
<a id="more"></a>

<h1 id="暴力法"><a href="#暴力法" class="headerlink" title="暴力法"></a>暴力法</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minNumber</span>(<span class="params">nums</span>) -&gt; str:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">compare</span>(<span class="params">a: <span class="built_in">str</span>, b: <span class="built_in">str</span></span>)-&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">int</span>(a + b) &gt;= <span class="built_in">int</span>(b + a):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    strs = [<span class="built_in">str</span>(num) <span class="keyword">for</span> num <span class="keyword">in</span> nums]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(strs)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i + <span class="number">1</span>, <span class="built_in">len</span>(strs)):</span><br><span class="line">            <span class="keyword">if</span> compare(strs[i], strs[j]):</span><br><span class="line">                strs[i], strs[j] = strs[j], strs[i]</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(strs)</span><br></pre></td></tr></table></figure>
<h1 id="快排及应用"><a href="#快排及应用" class="headerlink" title="快排及应用"></a>快排及应用</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span>(<span class="params">num_str</span>) -&gt; str:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">partition</span>(<span class="params">left, right</span>):</span></span><br><span class="line">        <span class="keyword">if</span> left &gt;= right:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        i, j = left, right</span><br><span class="line">        <span class="keyword">while</span> i &lt; j:</span><br><span class="line">            <span class="keyword">while</span> nums[j] &gt;= nums[left] <span class="keyword">and</span> i &lt; j:</span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> nums[i] &lt;= nums[left] <span class="keyword">and</span> i &lt; j:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            nums[i], nums[j] = nums[j], nums[i]</span><br><span class="line">        <span class="comment"># 找到合适的i, i的左边均 “小于” left, i的右边均 “大于” left</span></span><br><span class="line">        nums[left], nums[i] = nums[i], nums[left]</span><br><span class="line">        partition(left, i - <span class="number">1</span>)</span><br><span class="line">        partition(i + <span class="number">1</span>, right)</span><br><span class="line">    partition(<span class="number">0</span>, <span class="built_in">len</span>(num_str) - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> nums</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minNumber</span>(<span class="params">num_str</span>) -&gt; str:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span>(<span class="params">left, right</span>):</span></span><br><span class="line">        <span class="keyword">if</span> left &gt;= right:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        i, j = left, right</span><br><span class="line">        <span class="keyword">while</span> i &lt; j:</span><br><span class="line">            <span class="comment"># 排序规则变动</span></span><br><span class="line">            <span class="comment"># str_a + str_b &gt; str_b + str_a, 定义 str_a &quot;大于&quot; str_b</span></span><br><span class="line">            <span class="comment"># 反之, str_a &quot;小于&quot; str_b</span></span><br><span class="line">            <span class="keyword">while</span> nums[j] + nums[left] &gt;= nums[left] + nums[j] <span class="keyword">and</span> i &lt; j:</span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">            <span class="comment"># nums[j] + nums[left] &lt; nums[left] + nums[j], j &quot;小于&quot; left</span></span><br><span class="line">            <span class="keyword">while</span> nums[i] + nums[left] &lt;= nums[left] + nums[i] <span class="keyword">and</span> i &lt; j:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="comment"># nums[i] + nums[left] &lt; nums[left] + nums[i], i &quot;大于&quot; left </span></span><br><span class="line">            nums[i], nums[j] = nums[j], nums[i]</span><br><span class="line">        <span class="comment"># 找到合适的i, i的左边均 “小于” left, i的右边均 “大于” left</span></span><br><span class="line">        nums[left], nums[i] = nums[i], nums[left]</span><br><span class="line">        quick_sort(left, i - <span class="number">1</span>)</span><br><span class="line">        quick_sort(i + <span class="number">1</span>, right)</span><br><span class="line">    nums = [<span class="built_in">str</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> num_str]</span><br><span class="line">    quick_sort(<span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(nums)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>CODING</category>
        <category>排序</category>
      </categories>
      <tags>
        <tag>排序应用</tag>
      </tags>
  </entry>
  <entry>
    <title>分割等和子集</title>
    <url>/2020/12/25/20-12-25_%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86/</url>
    <content><![CDATA[<p>给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。<br>注意: 每个数组中的元素不会超过 100 , 数组的大小不会超过 200<br>示例 1:<br>输入: [1, 5, 11, 5], 输出: true<br>解释: 数组可以分割成 [1, 5, 5] 和 [11].<br>示例 2:<br>输入: [1, 2, 3, 5], 输出: false<br>解释: 数组不能分割成两个元素和相等的子集.</p>
<a id="more"></a>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">canPartition</span>(<span class="params">nums</span>) -&gt; bool:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    dp[i][j]: 前i个是否能凑出j，return dp[size][target]</span></span><br><span class="line"><span class="string">    dp[][0] = True, dp[0][] = False, dp[0][0] = False</span></span><br><span class="line"><span class="string">    dp[i][j] = dp[i - 1][j] or dp[i - 1][j - nums[i - 1]]</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    summ = <span class="built_in">sum</span>(nums)</span><br><span class="line">    <span class="keyword">if</span> summ % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    size, target = <span class="built_in">len</span>(nums), summ // <span class="number">2</span></span><br><span class="line">    dp = [[<span class="literal">False</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(size + <span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(target + <span class="number">1</span>)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, size + <span class="number">1</span>):</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, size + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, target + <span class="number">1</span>):</span><br><span class="line">            dp[i][j] = dp[i - <span class="number">1</span>][j] <span class="keyword">or</span> dp[i - <span class="number">1</span>][j - nums[i - <span class="number">1</span>]]</span><br><span class="line">    <span class="keyword">return</span> dp[-<span class="number">1</span>][-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>CODING</category>
        <category>dp</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>旋转排序数组</title>
    <url>/2020/12/28/20-12-28-%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2]，注意数组中可能存在重复的元素。 </p>
<ul>
<li>找出其中最小的元素</li>
<li>找出指定的元素target，若不存在返回-1</li>
</ul>
<a id="more"></a>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findMin</span>(<span class="params">nums</span>) -&gt; int:</span></span><br><span class="line">    left, right = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> left &lt; right: <span class="comment"># 终止条件 left=right</span></span><br><span class="line">        mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] &gt; nums[right]:</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> nums[mid] &lt; nums[right]:</span><br><span class="line">            right = mid</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            right -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> nums[left] <span class="comment"># or nums[right]</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findTarget</span>(<span class="params">nums, target</span>) -&gt; int:</span></span><br><span class="line">    left, right = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> left &lt; right:</span><br><span class="line">        mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] &gt; nums[left]:</span><br><span class="line">            <span class="comment"># [left, mid) 有序</span></span><br><span class="line">            <span class="keyword">if</span> nums[left] &lt;= target <span class="keyword">and</span> target &lt;= nums[mid]:</span><br><span class="line">                right = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> nums[mid] &lt; nums[left]:</span><br><span class="line">            <span class="comment"># [left, mid) 不递增 [7,6,5,1,2,3]</span></span><br><span class="line">            <span class="keyword">if</span> target &gt;= nums[left] <span class="keyword">or</span> target &lt;= nums[mid]:</span><br><span class="line">                right = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> nums[mid] == nums[left]:</span><br><span class="line">            <span class="comment"># [8,1,2,8,8]</span></span><br><span class="line">            <span class="keyword">if</span> nums[left] == target:</span><br><span class="line">                right = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> left <span class="keyword">if</span> nums[left] == target <span class="keyword">else</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>CODING</category>
        <category>dp</category>
      </categories>
      <tags>
        <tag>快手</tag>
        <tag>好未来</tag>
        <tag>滴滴</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式匹配</title>
    <url>/2020/12/28/20-12-28-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/</url>
    <content><![CDATA[<p>给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 ‘.’ 和 ‘<em>‘ 的正则表达式匹配，’.’ 匹配任意单个字符，’</em>‘ 匹配零个或多个前面的那一个元素。所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串<br>示例 1<br>输入：s = “aa” p = “a”，输出：false，解释：”a” 无法匹配 “aa” 整个字符串<br>示例 2<br>输入：s = “ab” p = “.<em>“，输出：true，解释：”.</em>“ 表示可匹配零个或多个（’<em>‘）任意字符（’.’）<br>示例 3<br>输入：s = “aab” p = “c</em>a<em>b”，输出：true，解释：因为 ‘</em>‘ 表示零个或多个，这里 ‘c’ 为 0 个, ‘a’ 被重复一次。因此可以匹配字符串 “aab”</p>
<a id="more"></a>
<img src="/images/正则表达式.jpg" width=80% height=50% align=center/>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isMatch</span>(<span class="params">s: <span class="built_in">str</span>, p: <span class="built_in">str</span></span>) -&gt; bool:</span></span><br><span class="line">    <span class="comment"># 边界条件，考虑 s 或 p 分别为空的情况</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> p: </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> s</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> s <span class="keyword">and</span> <span class="built_in">len</span>(p) == <span class="number">1</span>: </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    m, n = <span class="built_in">len</span>(s), <span class="built_in">len</span>(p)</span><br><span class="line">    dp = [[<span class="literal">False</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m + <span class="number">1</span>)]</span><br><span class="line">    <span class="comment"># 初始状态</span></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">True</span></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> p[j - <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>: <span class="comment"># p的第j个</span></span><br><span class="line">            dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j - <span class="number">2</span>] <span class="comment"># p的前j个 与 前 j-2 个的关系</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,m + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> s[i - <span class="number">1</span>] == p[j - <span class="number">1</span>] <span class="keyword">or</span> p[j - <span class="number">1</span>] == <span class="string">&#x27;.&#x27;</span>:</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">elif</span> p[j - <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                <span class="comment"># ‘*’前面的字符匹配s[i] 或者为&#x27;.&#x27;</span></span><br><span class="line">                <span class="keyword">if</span> p[j - <span class="number">2</span>] == s[i - <span class="number">1</span>] <span class="keyword">or</span> p[j - <span class="number">2</span>] == <span class="string">&#x27;.&#x27;</span>:</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j] <span class="keyword">or</span> dp[i][j - <span class="number">2</span>]</span><br><span class="line">                <span class="comment"># ‘*’匹配了0次前面的字符</span></span><br><span class="line">                <span class="keyword">else</span>:                       </span><br><span class="line">                    dp[i][j] = dp[i][j - <span class="number">2</span>] </span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dp[i][j] = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> dp[m][n]</span><br><span class="line">s = <span class="string">&quot;aab&quot;</span></span><br><span class="line">p = <span class="string">&quot;c*a*b&quot;</span></span><br><span class="line"><span class="comment">#s = &quot;&quot;, p = &#x27;.*&#x27; # true</span></span><br><span class="line">print(isMatch(s, p))</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>CODING</category>
        <category>dp</category>
      </categories>
  </entry>
  <entry>
    <title>顺时针打印矩阵</title>
    <url>/2020/12/28/20-12-28-%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5/</url>
    <content><![CDATA[<p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字<br>示例 1<br>输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]<br>输出：[1,2,3,6,9,8,7,4,5]<br>示例 2<br>输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]<br>输出：[1,2,3,4,8,12,11,10,9,5,6,7]</p>
<a id="more"></a>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">spiralOrder</span>(<span class="params">matrix</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> matrix:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    left, right, top, bottom, res = <span class="number">0</span>, <span class="built_in">len</span>(matrix[<span class="number">0</span>]) - <span class="number">1</span>, <span class="number">0</span>, <span class="built_in">len</span>(matrix) - <span class="number">1</span>, []</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(left, right + <span class="number">1</span>):</span><br><span class="line">            res.append(matrix[top][i])<span class="comment"># 从左到右</span></span><br><span class="line">        top += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> top &gt; bottom:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(top, bottom + <span class="number">1</span>):</span><br><span class="line">            res.append(matrix[j][right]) <span class="comment"># 从下到上</span></span><br><span class="line">        right -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> right &lt; left:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(right, left - <span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            res.append(matrix[bottom][k]) <span class="comment"># 从右到左</span></span><br><span class="line">        bottom -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> top &gt; bottom:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">for</span> l <span class="keyword">in</span> <span class="built_in">range</span>(bottom, top - <span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            res.append(matrix[l][left]) <span class="comment"># 从上到下</span></span><br><span class="line">        left += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> right &lt; left:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>CODING</category>
      </categories>
      <tags>
        <tag>快手</tag>
        <tag>头条</tag>
        <tag>滴滴</tag>
      </tags>
  </entry>
</search>
