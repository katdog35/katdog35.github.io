<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>数组的有序拆分</title>
    <url>/2020/08/25/20-08-25_%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%89%E5%BA%8F%E6%8B%86%E5%88%86/</url>
    <content><![CDATA[<p>实现一个数组的有序拆分<br>给定一个浮点数组及 2个阀值l 和 h，l &lt; h<br>对数组排序满足，数组左边均小于l，右边均大于h，中间部分在[l, h]之间<br>时间复杂度O(N), 额外空间复杂度O(1)</p>
<a id="more"></a>
<p>```python<br>def splitArr(arr, l, h):<br>    def f(arr, l):<br>        length = len(arr)<br>        if length == 0:<br>            return<br>        start = 0<br>        end = length - 1<br>        cur = 0<br>        while cur &lt;= end:<br>            if arr[cur] &lt; l:<br>                arr[cur], arr[start] = arr[start], arr[cur]<br>                start += 1<br>                cur += 1<br>            elif arr[cur] == l:<br>                cur += 1<br>            elif arr[cur] &gt; l:<br>                arr[cur], arr[end] = arr[end], arr[cur]<br>                end -= 1<br>    f(arr, l)<br>    f(arr, h)<br>    return arr</p>
<p>arr = [1,2,5,4,3,7,2,5,1,9,3,2,8]<br>print(splitArr(arr, 4, 5))```</p>
]]></content>
      <categories>
        <category>CODING</category>
      </categories>
      <tags>
        <tag>百度</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>只出现一次的字符</title>
    <url>/2020/12/20/20-12-20_%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6/</url>
    <content><![CDATA[<p>数组中只有一个单个元素，其他元素成对，找到只出现一次的元素</p>
<ul>
<li>成对出现，异或 ^，O（N）</li>
<li>成对连续出现，根据奇偶性二分</li>
</ul>
<a id="more"></a>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bs</span>(<span class="params">arr</span>):</span></span><br><span class="line">    left, right = <span class="number">0</span>, <span class="built_in">len</span>(arr) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> left &lt; right:</span><br><span class="line">        mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> mid - <span class="number">1</span> &gt;= left <span class="keyword">and</span> mid + <span class="number">1</span> &lt;= right <span class="keyword">and</span> arr[mid] != arr[mid - <span class="number">1</span>] <span class="keyword">and</span> arr[mid] != arr[mid + <span class="number">1</span>]:</span><br><span class="line">            <span class="keyword">return</span> mid, arr[mid]</span><br><span class="line">        <span class="keyword">elif</span> mid + <span class="number">1</span> &lt;= right <span class="keyword">and</span> arr[mid] == arr[mid + <span class="number">1</span>]:</span><br><span class="line">            length = mid + <span class="number">1</span> - left + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> length % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">                right = mid - <span class="number">1</span> <span class="comment"># mid = mid + 1 且为 mid + 1 左边长度为奇数, right -&gt; mid - 1</span></span><br><span class="line">            <span class="keyword">else</span>: </span><br><span class="line">                left = mid + <span class="number">2</span>  <span class="comment"># mid = mid + 1 且为 mid + 1 右边长度为奇数, right -&gt; mid + 2</span></span><br><span class="line">                <span class="comment"># left = mid</span></span><br><span class="line">        <span class="keyword">elif</span> mid - <span class="number">1</span> &gt;= left <span class="keyword">and</span> arr[mid] == arr[mid - <span class="number">1</span>]:</span><br><span class="line">            length = mid - left + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> length % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">                right = mid - <span class="number">2</span> <span class="comment"># mid - 1 = mid 且为 mid 左边长度为奇数, right -&gt; mid -2</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left = mid + <span class="number">1</span> <span class="comment"># mid - 1 = mid 且为mid 右边长度为奇数, right -&gt; mid + 1</span></span><br><span class="line">    <span class="comment"># left = right</span></span><br><span class="line">    <span class="comment"># 【1，2，2】;【1，1，2】的情况</span></span><br><span class="line">    <span class="keyword">return</span> left, arr[left]</span><br><span class="line"> </span><br><span class="line">arr = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">arr = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">5</span>]</span><br><span class="line">print(bs(arr))</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>CODING</category>
        <category>二分</category>
      </categories>
      <tags>
        <tag>快手</tag>
        <tag>头条</tag>
      </tags>
  </entry>
  <entry>
    <title>柱状图中的最大矩形</title>
    <url>/2020/12/20/20-12-20_%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2/</url>
    <content><![CDATA[<p>给定一个仅包含 0 和 1 的二维二进制矩阵，找出只包含 1 的最大矩形，并返回其面积<br>输入:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">    [<span class="string">&quot;1&quot;</span>,<span class="string">&quot;0&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;0&quot;</span>,<span class="string">&quot;0&quot;</span>],</span><br><span class="line">    [<span class="string">&quot;1&quot;</span>,<span class="string">&quot;0&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;1&quot;</span>],</span><br><span class="line">    [<span class="string">&quot;1&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;1&quot;</span>],</span><br><span class="line">    [<span class="string">&quot;1&quot;</span>,<span class="string">&quot;0&quot;</span>,<span class="string">&quot;0&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;0&quot;</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>输出: 6 </p>
<a id="more"></a>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">largestRectangleArea2</span>(<span class="params">self, heights</span>) -&gt; int:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    暴力法 O(N^2), 以 heights[i] 的高度为高，求左右满足的宽</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    lg = <span class="built_in">len</span>(heights)</span><br><span class="line">    maxx = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(lg):</span><br><span class="line">        tmp = heights[i]</span><br><span class="line">        left, right = i, i</span><br><span class="line">        <span class="keyword">while</span> left &gt; <span class="number">0</span> <span class="keyword">and</span> heights[left - <span class="number">1</span>] &gt;= heights[i]:</span><br><span class="line">            left -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> right &lt; lg - <span class="number">1</span> <span class="keyword">and</span> heights[right + <span class="number">1</span>] &gt;= heights[i]:</span><br><span class="line">            right += <span class="number">1</span></span><br><span class="line">        maxx = <span class="built_in">max</span>(tmp * (right - left + <span class="number">1</span>), maxx)</span><br><span class="line">    <span class="keyword">return</span> maxx</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">largestRectangleArea</span>(<span class="params">heights</span>) -&gt; int:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    单调栈, stack 递增</span></span><br><span class="line"><span class="string">    cur 比 stack[-1]大，入栈; </span></span><br><span class="line"><span class="string">    cur 比 stack[-1]小，依次出栈至 stack[-1]小于cur</span></span><br><span class="line"><span class="string">    以出栈元素的值为高，求宽，更新最值</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    heights.append(<span class="number">0</span>) <span class="comment"># 判断最后一个元素为高的情况</span></span><br><span class="line">    lg = <span class="built_in">len</span>(heights)</span><br><span class="line">    stack = [<span class="number">0</span>]</span><br><span class="line">    maxx = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, lg):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> stack <span class="keyword">and</span> heights[stack[-<span class="number">1</span>]] &lt;= heights[i]:</span><br><span class="line">            stack.append(i)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> heights[stack[-<span class="number">1</span>]] &gt;= heights[i]:</span><br><span class="line">                h = heights[stack[-<span class="number">1</span>]]</span><br><span class="line">                stack.pop()</span><br><span class="line">                <span class="comment"># stack 为空，说明当前height[i] 小于 i之前所有的值</span></span><br><span class="line">                 </span><br><span class="line">                w = i <span class="keyword">if</span> <span class="keyword">not</span> stack <span class="keyword">else</span> i - (stack[-<span class="number">1</span>] + <span class="number">1</span>)</span><br><span class="line">                maxx = <span class="built_in">max</span>(maxx, h*w)</span><br><span class="line">            stack.append(i)</span><br><span class="line">    <span class="keyword">return</span> maxx</span><br><span class="line"><span class="comment"># i=3 结束时，stack = [0,3]；i=4, height[4]=0时，w = i - (0 + 1) = 3</span></span><br><span class="line">heights = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>] </span><br><span class="line">print(largestRectangleArea(heights))</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>CODING</category>
        <category>单调栈</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的直径</title>
    <url>/2020/12/23/20-12-22_%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/</url>
    <content><![CDATA[<p>给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点<br>示例 :<br>给定二叉树<br>            1<br>          / <br>         2   3<br>        / \<br>       4   5<br>返回 3, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]</p>
<a id="more"></a>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">diameterOfBinaryTree</span>(<span class="params">root</span>) -&gt; int:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">root</span>):</span></span><br><span class="line">        <span class="comment"># 返回: 以root 为根结点的最长路径的最大节点个数</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="comment"># focus on one node</span></span><br><span class="line">        left = dfs(root.left)</span><br><span class="line">        right = dfs(root.right)</span><br><span class="line">        <span class="keyword">global</span> node_nums</span><br><span class="line">        node_nums = <span class="built_in">max</span>(node_nums, left + right + <span class="number">1</span>)</span><br><span class="line">        <span class="comment"># 左右子树只能贡献一边，向上递归</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(left, right) + <span class="number">1</span> </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">global</span> node_nums</span><br><span class="line">    node_nums = <span class="number">1</span></span><br><span class="line">    dfs(root)</span><br><span class="line">    <span class="keyword">return</span> node_nums - <span class="number">1</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>CODING</category>
        <category>树</category>
      </categories>
      <tags>
        <tag>头条</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>sqrt(x)</title>
    <url>/2020/12/22/20-12-22_%E5%BC%80%E5%B9%B3%E6%96%B9/</url>
    <content><![CDATA[<p>给定浮点数x, 求sqrt(x)</p>
<a id="more"></a>

<h1 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h1><ul>
<li>当 x&lt;1 时，注意左右边界<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sqrt</span>(<span class="params">x, error</span>):</span></span><br><span class="line">    <span class="comment"># 二分</span></span><br><span class="line">    <span class="keyword">if</span> x &lt;= <span class="number">1</span>:</span><br><span class="line">        left, right = x, <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        left, right = <span class="number">1</span>, x</span><br><span class="line">    <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">        mid = left + (right - left) / <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">abs</span>(mid * mid - x) &lt;= error:</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        <span class="keyword">elif</span> mid * mid - x &gt; <span class="number">0</span>:</span><br><span class="line">            right = mid</span><br><span class="line">        <span class="keyword">elif</span> mid * mid - x &lt; <span class="number">0</span>:</span><br><span class="line">            left = mid</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="牛顿法"><a href="#牛顿法" class="headerlink" title="牛顿法"></a>牛顿法</h1><ul>
<li>切线是曲线的近似拟合<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sqrt</span>(<span class="params">target, error</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    f(x) = x^2 - target = 0</span></span><br><span class="line"><span class="string">    f&#x27;(x) = 2 * x</span></span><br><span class="line"><span class="string">    切线方程： 2 * x * (x_hat - x) + f(x)</span></span><br><span class="line"><span class="string">    x_hat = (x + target / x) / 2</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    x = target</span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">abs</span>(x * x - target) &gt; error:</span><br><span class="line">        x = (x + target / x) / <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>CODING</category>
        <category>二分</category>
      </categories>
      <tags>
        <tag>快手</tag>
        <tag>好未来</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>打家劫舍I/II/III</title>
    <url>/2020/12/22/20-12-22_%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/</url>
    <content><![CDATA[<p>I<br>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。</p>
<p>II<br>这个地方所有的房屋都围成一圈，这意味着第一个房屋和最后一个房屋是紧挨着的</p>
<p>III<br>这个地方的所有房屋的排列类似于一棵二叉树。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警</p>
<a id="more"></a>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rob1</span>(<span class="params">arr</span>):</span></span><br><span class="line">    size = <span class="built_in">len</span>(arr)</span><br><span class="line">    <span class="keyword">if</span> size == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> size == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> arr[<span class="number">0</span>]</span><br><span class="line">    dp = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(size)]</span><br><span class="line">    dp[<span class="number">0</span>], dp[<span class="number">1</span>] = arr[<span class="number">0</span>], <span class="built_in">max</span>(arr[<span class="number">0</span>], arr[<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, size):</span><br><span class="line">        dp[i] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>], dp[i - <span class="number">2</span>] + arr[i])</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(dp)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rob2</span>(<span class="params">arr</span>):</span></span><br><span class="line">    size = <span class="built_in">len</span>(arr)</span><br><span class="line">    <span class="keyword">if</span> size == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> size == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> arr[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(rob1(arr[:-<span class="number">1</span>]), rob1(arr[<span class="number">1</span>:]))</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rob3</span>(<span class="params">root</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">node</span>):</span></span><br><span class="line">        <span class="comment"># return node 偷 / 不偷 能获取的最大值</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>, <span class="number">0</span> <span class="comment"># 偷， 不偷</span></span><br><span class="line">        left_res = dfs(node.left)</span><br><span class="line">        right_res = dfs(node.right)</span><br><span class="line">        <span class="comment"># 当前 node 偷</span></span><br><span class="line">        res1 = left_res[<span class="number">1</span>] + right_res[<span class="number">1</span>] + node.val</span><br><span class="line">        <span class="comment"># 当前 node 不偷</span></span><br><span class="line">        res2 = <span class="built_in">max</span>(left_res) + <span class="built_in">max</span>(right_res)</span><br><span class="line">        <span class="keyword">return</span> res1, res2</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(dfs(root))</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>CODING</category>
        <category>dp</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>数组中的逆序对</title>
    <url>/2020/12/23/20-12-22_%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9/</url>
    <content><![CDATA[<p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P</p>
<a id="more"></a>

<h1 id="暴力法"><a href="#暴力法" class="headerlink" title="暴力法"></a>暴力法</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reversePairs1</span>(<span class="params">nums</span>):</span></span><br><span class="line">    <span class="comment"># O(N^2)</span></span><br><span class="line">    ans, size = <span class="number">0</span>, <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="keyword">if</span> size &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(size - <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i + <span class="number">1</span>, size):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt; nums[j]:</span><br><span class="line">                ans += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<h1 id="归并排序应用"><a href="#归并排序应用" class="headerlink" title="归并排序应用"></a>归并排序应用</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reversePairs2</span>(<span class="params">nums</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge_sort</span>(<span class="params">nums</span>):</span></span><br><span class="line">        <span class="comment"># 递归终止条件</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums) &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> nums</span><br><span class="line">        mid = <span class="built_in">len</span>(nums) // <span class="number">2</span></span><br><span class="line">        l_res = merge_sort(nums[ :mid])</span><br><span class="line">        r_res = merge_sort(nums[mid: ])</span><br><span class="line">        <span class="keyword">return</span> merge(l_res, r_res)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">left, right</span>):</span></span><br><span class="line">        lst = []</span><br><span class="line">        i, j = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(left) <span class="keyword">and</span> j &lt; <span class="built_in">len</span>(right):</span><br><span class="line">            <span class="keyword">if</span> left[i] &lt;= right[j]:</span><br><span class="line">                lst.append(left[i])</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">global</span> ans</span><br><span class="line">                ans += <span class="built_in">len</span>(left) - i</span><br><span class="line">                lst.append(right[j])</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">        lst.extend(left[i:])</span><br><span class="line">        lst.extend(right[j:])</span><br><span class="line">        <span class="keyword">return</span> lst</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">global</span> ans</span><br><span class="line">    ans = <span class="number">0</span></span><br><span class="line">    nums_sorted = merge_sort(nums)</span><br><span class="line">    <span class="keyword">return</span> nums_sorted, ans</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>CODING</category>
        <category>排序</category>
      </categories>
      <tags>
        <tag>头条</tag>
        <tag>归并排序</tag>
      </tags>
  </entry>
  <entry>
    <title>最长有效括号长度</title>
    <url>/2020/12/22/20-12-22_%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7%E9%95%BF%E5%BA%A6/</url>
    <content><![CDATA[<p>给定一个只包含 ‘(‘ 和 ‘)’ 的字符串，找出最长的包含有效括号的子串的长度<br>示例 1:<br>输入: “(()”<br>输出: 2<br>解释: 最长有效括号子串为 “()”</p>
<p>示例 2:<br>输入: “)()())”<br>输出: 4<br>解释: 最长有效括号子串为 “()()”</p>
<a id="more"></a>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longestValidParentheses</span>(<span class="params">s: <span class="built_in">str</span></span>) -&gt; int:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    dp[i]: 以s[i]结尾的最长有效括号子串长度</span></span><br><span class="line"><span class="string">    if s[i] = &#x27;(&#x27;:</span></span><br><span class="line"><span class="string">        dp[i] = 0</span></span><br><span class="line"><span class="string">    else: # s[i] = &#x27;)&#x27;</span></span><br><span class="line"><span class="string">        if s[i - 1] = &#x27;(&#x27;:</span></span><br><span class="line"><span class="string">            dp[i] = dp[i - 1] + 2 </span></span><br><span class="line"><span class="string">        else: # s[i - 1] = &#x27;)&#x27;</span></span><br><span class="line"><span class="string">            if s[i - dp[i - 1] - 1] = &#x27;(&#x27;:</span></span><br><span class="line"><span class="string">                dp[i] = 2 + dp[i - 1] + dp[i - dp[i - 1] - 1 - 1]</span></span><br><span class="line"><span class="string">    注意可能越界, i &gt; 0，i - dp[i - 1] - 1 &gt;= 0</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    dp = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s))]</span><br><span class="line">    ans = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">        <span class="keyword">if</span> s[i] == <span class="string">&#x27;)&#x27;</span>:<span class="comment"># 只考虑以&#x27;)&#x27;结尾的子串</span></span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> s[i - <span class="number">1</span>] == <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">                dp[i] = dp[i - <span class="number">2</span>] + <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> s[i - <span class="number">1</span>] == <span class="string">&#x27;)&#x27;</span>:</span><br><span class="line">                <span class="keyword">if</span> i - dp[i - <span class="number">1</span>] - <span class="number">1</span> &gt;= <span class="number">0</span> <span class="keyword">and</span> s[i - dp[i - <span class="number">1</span>] - <span class="number">1</span>] == <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">                    <span class="keyword">if</span> i - dp[i - <span class="number">1</span>] - <span class="number">2</span> &gt;= <span class="number">0</span>:<span class="comment"># 当前合法子串，前面还有子串的情况</span></span><br><span class="line">                        dp[i] = <span class="number">2</span> + dp[i - <span class="number">1</span>] + dp[i - dp[i - <span class="number">1</span>] - <span class="number">2</span>]</span><br><span class="line">                    <span class="keyword">else</span>: <span class="comment"># 当前合法子串，前面没有子串的情况</span></span><br><span class="line">                        dp[i] = <span class="number">2</span> + dp[i - <span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(dp)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longestValidParentheses2</span>(<span class="params">s: <span class="built_in">str</span></span>) -&gt; int:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    中心拓展法 def expand(l, r)</span></span><br><span class="line"><span class="string">    return [l, r]: 有效括号的左右边界</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    dic = &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">expand</span>(<span class="params">l, r</span>):</span></span><br><span class="line">        <span class="keyword">while</span> l &gt;= <span class="number">0</span> <span class="keyword">and</span> r &lt; <span class="built_in">len</span>(s) <span class="keyword">and</span> s[l] == <span class="string">&#x27;(&#x27;</span> <span class="keyword">and</span> s[r] == <span class="string">&#x27;)&#x27;</span>:</span><br><span class="line">            l -= <span class="number">1</span></span><br><span class="line">            r += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> l + <span class="number">1</span> - <span class="number">1</span> <span class="keyword">in</span> dic:</span><br><span class="line">            <span class="keyword">return</span> expand(dic[l + <span class="number">1</span> - <span class="number">1</span>], r - <span class="number">1</span>)</span><br><span class="line">        dic[r - <span class="number">1</span>] = l + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> [l + <span class="number">1</span>, r - <span class="number">1</span>]</span><br><span class="line">    </span><br><span class="line">    ans = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s) - <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> s[i] == <span class="string">&#x27;(&#x27;</span> <span class="keyword">and</span> s[i + <span class="number">1</span>] == <span class="string">&#x27;)&#x27;</span>:</span><br><span class="line">            l, r = expand(i, i + <span class="number">1</span>)</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, r - l + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longestValidParentheses3</span>(<span class="params">s</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    栈</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    q = []</span><br><span class="line">    start, ans = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">        <span class="keyword">if</span> s[i] == <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">            q.append(i)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> q: </span><br><span class="line">                start = i + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                q.pop()</span><br><span class="line">                <span class="keyword">if</span> q:</span><br><span class="line">                    ans = <span class="built_in">max</span>(ans, i - q[-<span class="number">1</span>])</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    ans = <span class="built_in">max</span>(ans, i - start + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>CODING</category>
        <category>dp</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>滴滴</tag>
      </tags>
  </entry>
  <entry>
    <title>滑动窗口最大值</title>
    <url>/2020/12/22/20-12-22_%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC/</url>
    <content><![CDATA[<p>给定一个数组 nums 和滑动窗口的大小 k，请找出所有滑动窗口里的最大值<br>示例:<br>输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3<br>输出: [3,3,5,5,6,7]<br>解释:<br>    [1  3  -1] -3  5  3  6  7   =&gt; 3<br>    1 [3  -1  -3] 5  3  6  7    =&gt; 3<br>    1  3 [-1  -3  5] 3  6  7    =&gt; 5<br>    1  3  -1 [-3  5  3] 6  7    =&gt; 5<br>    1  3  -1  -3 [5  3  6] 7    =&gt; 6<br>    1  3  -1  -3  5 [3  6  7]   =&gt; 7<br>提示：你可以假设 k 总是有效的，在输入数组不为空的情况下，1 ≤ k ≤ 输入数组的大小</p>
<a id="more"></a>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxSlidingWindow</span>(<span class="params">nums, k</span>):</span></span><br><span class="line">    <span class="comment"># 暴力法， O(KN)</span></span><br><span class="line">    left, right = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    lst = []</span><br><span class="line">    <span class="keyword">while</span> right &lt;= <span class="built_in">len</span>(nums) - <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">while</span> right - left &lt; k:</span><br><span class="line">            right += <span class="number">1</span></span><br><span class="line">        lst.append(<span class="built_in">max</span>(nums[left: right]))</span><br><span class="line">        left += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> lst</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxSlidingWindow</span>(<span class="params">nums, k</span>):</span></span><br><span class="line">    <span class="comment"># 单调栈</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    res, stack = [], []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">        <span class="comment"># 窗口左边的元素弹出</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(deque) &gt; <span class="number">0</span> <span class="keyword">and</span> stack[<span class="number">0</span>] &lt;= i - k:</span><br><span class="line">            stack.pop(<span class="number">0</span>)</span><br><span class="line">        <span class="comment"># 维护栈内元素有序</span></span><br><span class="line">        <span class="keyword">while</span> deque <span class="keyword">and</span> nums[stack[-<span class="number">1</span>]] &lt; nums[i]:</span><br><span class="line">            stack.pop()</span><br><span class="line">        deque.append(i)</span><br><span class="line">        <span class="keyword">if</span> i &gt;= k - <span class="number">1</span>:</span><br><span class="line">            res.append(nums[deque[<span class="number">0</span>]])</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>CODING</category>
        <category>单调栈</category>
      </categories>
      <tags>
        <tag>头条</tag>
      </tags>
  </entry>
</search>
